diff --git a/shlib-versions b/shlib-versions
index 40469bd..2077b26 100644
--- a/shlib-versions
+++ b/shlib-versions
@@ -25,6 +25,7 @@ s390x-.*-linux.*        DEFAULT			GLIBC_2.2
 powerpc64-.*-linux.*	DEFAULT			GLIBC_2.3
 powerpc.*le-.*-linux.*	DEFAULT			GLIBC_2.17
 .*-.*-gnu-gnu.*		DEFAULT			GLIBC_2.2.6
+riscv-.*-linux.*	DEFAULT			GLIBC_2.20
 
 # Configuration		Library=version		Earliest symbol set (optional)
 # -------------		---------------		------------------------------
diff --git a/sysdeps/riscv/Implies b/sysdeps/riscv/Implies
new file mode 100644
index 0000000..b1da7b4
--- /dev/null
+++ b/sysdeps/riscv/Implies
@@ -0,0 +1,7 @@
+init_array
+
+ieee754/flt-32
+ieee754/dbl-64
+
+# This needs to change to support rv32
+riscv/rv64
diff --git a/sysdeps/riscv/Makefile b/sysdeps/riscv/Makefile
new file mode 100644
index 0000000..cd9598a
--- /dev/null
+++ b/sysdeps/riscv/Makefile
@@ -0,0 +1,49 @@
+ifneq ($(all-rtld-routines),)
+CFLAGS-rtld.c += -mno-plt
+CFLAGS-dl-load.c += -mno-plt
+CFLAGS-dl-cache.c += -mno-plt
+CFLAGS-dl-lookup.c += -mno-plt
+CFLAGS-dl-object.c += -mno-plt
+CFLAGS-dl-reloc.c += -mno-plt
+CFLAGS-dl-deps.c += -mno-plt
+CFLAGS-dl-runtime.c += -mno-plt
+CFLAGS-dl-error.c += -mno-plt
+CFLAGS-dl-init.c += -mno-plt
+CFLAGS-dl-fini.c += -mno-plt
+CFLAGS-dl-debug.c += -mno-plt
+CFLAGS-dl-misc.c += -mno-plt
+CFLAGS-dl-version.c += -mno-plt
+CFLAGS-dl-profile.c += -mno-plt
+CFLAGS-dl-conflict.c += -mno-plt
+CFLAGS-dl-tls.c += -mno-plt
+CFLAGS-dl-origin.c += -mno-plt
+CFLAGS-dl-scope.c += -mno-plt
+CFLAGS-dl-execstack.c += -mno-plt
+CFLAGS-dl-caller.c += -mno-plt
+CFLAGS-dl-open.c += -mno-plt
+CFLAGS-dl-close.c += -mno-plt
+CFLAGS-dl-sysdep.c += -mno-plt
+CFLAGS-dl-environ.c += -mno-plt
+CFLAGS-dl-minimal.c += -mno-plt
+CFLAGS-dl-static.c += -mno-plt
+CFLAGS-dl-brk.c += -mno-plt
+CFLAGS-dl-sbrk.c += -mno-plt
+CFLAGS-dl-getcwd.c += -mno-plt
+CFLAGS-dl-openat64.c += -mno-plt
+CFLAGS-dl-opendir.c += -mno-plt
+CFLAGS-dl-fxstatat64.c += -mno-plt
+endif
+
+CFLAGS-closedir.c += -mno-plt
+CFLAGS-exit.c += -mno-plt
+CFLAGS-cxa_atexit.c += -mno-plt
+
+ifeq ($(subdir),misc)
+sysdep_headers += sys/asm.h sgidefs.h
+endif
+
+ifeq ($(subdir),rt)
+librt-sysdep_routines += rt-sysdep
+endif
+
+ASFLAGS-.os += $(pic-ccflag)
diff --git a/sysdeps/riscv/Versions b/sysdeps/riscv/Versions
new file mode 100644
index 0000000..5a0c2d2
--- /dev/null
+++ b/sysdeps/riscv/Versions
@@ -0,0 +1,5 @@
+libc {
+  GLIBC_2.14 {
+    __memcpy_g;
+  }
+}
diff --git a/sysdeps/riscv/__longjmp.S b/sysdeps/riscv/__longjmp.S
new file mode 100644
index 0000000..88f720e
--- /dev/null
+++ b/sysdeps/riscv/__longjmp.S
@@ -0,0 +1,67 @@
+/* Copyright (C) 1996, 1997, 2000, 2002, 2003, 2004
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+ENTRY (__longjmp)
+	REG_L ra,  0*SZREG(a0)
+	REG_L s0,  1*SZREG(a0)
+	REG_L s1,  2*SZREG(a0)
+	REG_L s2,  3*SZREG(a0)
+	REG_L s3,  4*SZREG(a0)
+	REG_L s4,  5*SZREG(a0)
+	REG_L s5,  6*SZREG(a0)
+	REG_L s6,  7*SZREG(a0)
+	REG_L s7,  8*SZREG(a0)
+	REG_L s8,  9*SZREG(a0)
+	REG_L s9, 10*SZREG(a0)
+	REG_L s10,11*SZREG(a0)
+	REG_L s11,12*SZREG(a0)
+	REG_L sp, 13*SZREG(a0)
+	REG_L tp, 14*SZREG(a0)
+
+#ifdef __riscv_hard_float
+	REG_L a3, 15*SZREG(a0)
+
+	fld  fs0, 16*SZREG+ 0*8(a0)
+	fld  fs1, 16*SZREG+ 1*8(a0)
+	fld  fs2, 16*SZREG+ 2*8(a0)
+	fld  fs3, 16*SZREG+ 3*8(a0)
+	fld  fs4, 16*SZREG+ 4*8(a0)
+	fld  fs5, 16*SZREG+ 5*8(a0)
+	fld  fs6, 16*SZREG+ 6*8(a0)
+	fld  fs7, 16*SZREG+ 7*8(a0)
+	fld  fs8, 16*SZREG+ 8*8(a0)
+	fld  fs9, 16*SZREG+ 9*8(a0)
+	fld  fs10,16*SZREG+10*8(a0)
+	fld  fs11,16*SZREG+11*8(a0)
+	fld  fs12,16*SZREG+12*8(a0)
+	fld  fs13,16*SZREG+13*8(a0)
+	fld  fs14,16*SZREG+14*8(a0)
+	fld  fs15,16*SZREG+15*8(a0)
+
+	fssr a3
+#endif
+
+	sltu a3, a1, 1    # a3 = (a1 == 0)
+	add  v0, a3, a1   # v0 = (a1 == 0 ? 1 : a1)
+	ret
+
+END(__longjmp)
diff --git a/sysdeps/riscv/bits/atomic.h b/sysdeps/riscv/bits/atomic.h
new file mode 100644
index 0000000..aaa62d7
--- /dev/null
+++ b/sysdeps/riscv/bits/atomic.h
@@ -0,0 +1,151 @@
+/* Low-level functions for atomic operations. Mips version.
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _MIPS_BITS_ATOMIC_H
+#define _MIPS_BITS_ATOMIC_H 1
+
+#include <inttypes.h>
+#include <sgidefs.h>
+
+typedef int32_t atomic32_t;
+typedef uint32_t uatomic32_t;
+typedef int_fast32_t atomic_fast32_t;
+typedef uint_fast32_t uatomic_fast32_t;
+
+typedef int64_t atomic64_t;
+typedef uint64_t uatomic64_t;
+typedef int_fast64_t atomic_fast64_t;
+typedef uint_fast64_t uatomic_fast64_t;
+
+typedef intptr_t atomicptr_t;
+typedef uintptr_t uatomicptr_t;
+typedef intmax_t atomic_max_t;
+typedef uintmax_t uatomic_max_t;
+
+#ifdef __riscv_atomic
+
+#define asm_amo(which, ordering, mem, value) ({ 		\
+  typeof(*mem) __tmp; 						\
+  if (sizeof(__tmp) == 4)					\
+    asm volatile (which ".w" ordering "\t%0, %z1, (%2)" : "=r"(__tmp) : "rJ"(value), "r"(mem)); \
+  else if (sizeof(__tmp) == 8)					\
+    asm volatile (which ".d" ordering "\t%0, %z1, (%2)" : "=r"(__tmp) : "rJ"(value), "r"(mem)); \
+  else								\
+    abort();							\
+  __tmp; })
+
+#define asm_load_reserved(ordering, mem) ({ 			\
+  typeof(*mem) __tmp; 						\
+  if (sizeof(__tmp) == 4)					\
+    asm volatile ("lr.w" ordering "\t%0, (%1)" : "=r"(__tmp) : "r"(mem)); \
+  else if (sizeof(__tmp) == 8)					\
+    asm volatile ("lr.d" ordering "\t%0, (%1)" : "=r"(__tmp) : "r"(mem)); \
+  else								\
+    abort();							\
+  __tmp; })
+
+#define asm_store_conditional(ordering, mem, value) \
+  asm_amo("sc", ordering, mem, value)
+
+/* Atomic compare and exchange. */
+
+#define atomic_cas(ordering, mem, newval, oldval) ({ 	\
+  typeof(*mem) __tmp; 						\
+  int __tmp2; 							\
+  if (sizeof(__tmp) == 4)					\
+    asm volatile ("1: lr.w" ordering "\t%0, (%2)\n"		\
+                  "bne\t%0, %z4, 1f\n"				\
+		  "sc.w" ordering "\t%1, %z3, (%2)\n"		\
+		  "bnez\t%1, 1b\n"				\
+		  "1:"						\
+		  : "=&r"(__tmp), "=&r"(__tmp2) : "r"(mem), "rJ"(newval), "rJ"(oldval)); \
+  else if (sizeof(__tmp) == 8)					\
+    asm volatile ("1: lr.d" ordering "\t%0, (%2)\n"		\
+                  "bne\t%0, %z4, 1f\n"				\
+		  "sc.d" ordering "\t%1, %z3, (%2)\n"		\
+		  "bnez\t%1, 1b\n"				\
+		  "1:"						\
+		  : "=&r"(__tmp), "=&r"(__tmp2) : "r"(mem), "rJ"(newval), "rJ"(oldval)); \
+  else								\
+    abort();							\
+  __tmp; })
+
+#define atomic_cas_bool(ordering, mem, newval, oldval) ({ 	\
+  __label__ failure, success;					\
+  typeof(*mem) __tmp; 						\
+  int __res;							\
+  if (sizeof(__tmp) == 4)					\
+    asm goto ("1: lr.w" ordering "\tt3, (%0)\n"			\
+                  "bne\tt3, %z2, %l[failure]\n"			\
+		  "sc.w" ordering "\tt3, %z1, (%0)\n"		\
+		  "bnez\tt3, 1b"				\
+		  : : "r"(mem), "rJ"(newval), "rJ"(oldval) : "t3" : failure); \
+  else if (sizeof(__tmp) == 8)					\
+    asm goto ("1: lr.d" ordering "\tt3, (%0)\n"			\
+                  "bne\tt3, %z2, %l[failure]\n"			\
+		  "sc.d" ordering "\tt3, %z1, (%0)\n"		\
+		  "bnez\tt3, 1b"				\
+		  : : "r"(mem), "rJ"(newval), "rJ"(oldval) : "t3" : failure); \
+  else								\
+    abort();							\
+  __res = 0;							\
+  goto success;							\
+failure:							\
+  __res = 1;							\
+success:							\
+  __res; })
+
+#define atomic_compare_and_exchange_val_acq(mem, newval, oldval) \
+  atomic_cas(".aq", mem, newval, oldval)
+
+#define atomic_compare_and_exchange_val_rel(mem, newval, oldval) \
+  atomic_cas(".rl", mem, newval, oldval)
+
+#define atomic_compare_and_exchange_bool_acq(mem, newval, oldval) \
+  atomic_cas_bool(".aq", mem, newval, oldval)
+
+#define atomic_compare_and_exchange_bool_rel(mem, newval, oldval) \
+  atomic_cas_bool(".rl", mem, newval, oldval)
+
+/* Atomic exchange (without compare).  */
+
+#define atomic_exchange_acq(mem, value) asm_amo("amoswap", ".aq", mem, value)
+#define atomic_exchange_rel(mem, value) asm_amo("amoswap", ".rl", mem, value)
+
+
+/* Atomically add value and return the previous (unincremented) value.  */
+
+#define atomic_exchange_and_add(mem, value) asm_amo("amoadd", "", mem, value)
+
+#define atomic_max(mem, value) asm_amo("amomaxu", "", mem, value)
+#define atomic_min(mem, value) asm_amo("amominu", "", mem, value)
+
+#define atomic_bit_test_set(mem, bit)                   \
+  ({ typeof(*mem) __mask = (typeof(*mem))1 << (bit);    \
+     asm_amo("amoor", "", mem, __mask) & __mask; })
+
+#define atomic_full_barrier() __sync_synchronize()
+
+#define catomic_exchange_and_add(mem, value)		\
+  atomic_exchange_and_add(mem, value)
+#define catomic_max(mem, value) atomic_max(mem, value)
+
+#endif /* __riscv_atomic */
+
+#endif /* bits/atomic.h */
diff --git a/sysdeps/riscv/bits/dlfcn.h b/sysdeps/riscv/bits/dlfcn.h
new file mode 100644
index 0000000..a5b5bf5
--- /dev/null
+++ b/sysdeps/riscv/bits/dlfcn.h
@@ -0,0 +1,66 @@
+/* System dependent definitions for run-time dynamic loading.
+   Copyright (C) 1996, 1997, 1999, 2000, 2001, 2004
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _DLFCN_H
+# error "Never use <bits/dlfcn.h> directly; include <dlfcn.h> instead."
+#endif
+
+/* The MODE argument to `dlopen' contains one of the following: */
+#define RTLD_LAZY	0x0001	/* Lazy function call binding.  */
+#define RTLD_NOW	0x0002	/* Immediate function call binding.  */
+#define RTLD_BINDING_MASK  0x3	/* Mask of binding time value.  */
+#define RTLD_NOLOAD	0x00008	/* Do not load the object.  */
+#define RTLD_DEEPBIND	0x00010	/* Use deep binding.  */
+
+/* If the following bit is set in the MODE argument to `dlopen',
+   the symbols of the loaded object and its dependencies are made
+   visible as if the object were linked directly into the program.  */
+#define RTLD_GLOBAL	0x0004
+
+/* Unix98 demands the following flag which is the inverse to RTLD_GLOBAL.
+   The implementation does this by default and so we can define the
+   value to zero.  */
+#define RTLD_LOCAL      0
+
+/* Do not delete object when closed.  */
+#define RTLD_NODELETE	0x01000
+
+#ifdef __USE_GNU
+/* To support profiling of shared objects it is a good idea to call
+   the function found using `dlsym' using the following macro since
+   these calls do not use the PLT.  But this would mean the dynamic
+   loader has no chance to find out when the function is called.  The
+   macro applies the necessary magic so that profiling is possible.
+   Rewrite
+	foo = (*fctp) (arg1, arg2);
+   into
+        foo = DL_CALL_FCT (fctp, (arg1, arg2));
+*/
+# define DL_CALL_FCT(fctp, args) \
+  (_dl_mcount_wrapper_check ((void *) (fctp)), (*(fctp)) args)
+
+__BEGIN_DECLS
+
+/* This function calls the profiling functions.  */
+extern void _dl_mcount_wrapper_check (void *__selfpc) __THROW;
+
+__END_DECLS
+
+#endif
diff --git a/sysdeps/riscv/bits/endian.h b/sysdeps/riscv/bits/endian.h
new file mode 100644
index 0000000..4aaf559
--- /dev/null
+++ b/sysdeps/riscv/bits/endian.h
@@ -0,0 +1,5 @@
+#ifndef _ENDIAN_H
+# error "Never use <bits/endian.h> directly; include <endian.h> instead."
+#endif
+
+#define __BYTE_ORDER __LITTLE_ENDIAN
diff --git a/sysdeps/riscv/bits/fenv.h b/sysdeps/riscv/bits/fenv.h
new file mode 100644
index 0000000..0ccf5cb
--- /dev/null
+++ b/sysdeps/riscv/bits/fenv.h
@@ -0,0 +1,57 @@
+/* Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _FENV_H
+# error "Never use <bits/fenv.h> directly; include <fenv.h> instead."
+#endif
+
+enum
+  {
+    FE_INEXACT = 0x01,
+#define FE_INEXACT	FE_INEXACT
+    FE_UNDERFLOW = 0x02,
+#define FE_UNDERFLOW	FE_UNDERFLOW
+    FE_OVERFLOW = 0x04,
+#define FE_OVERFLOW	FE_OVERFLOW
+    FE_DIVBYZERO = 0x08,
+#define FE_DIVBYZERO	FE_DIVBYZERO
+    FE_INVALID = 0x10,
+#define FE_INVALID	FE_INVALID
+  };
+
+#define FE_ALL_EXCEPT \
+	(FE_INEXACT | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID)
+
+enum
+  {
+    FE_TONEAREST = 0x0,
+#define FE_TONEAREST	FE_TONEAREST
+    FE_TOWARDZERO = 0x1,
+#define FE_TOWARDZERO	FE_TOWARDZERO
+    FE_DOWNWARD = 0x2,
+#define FE_DOWNWARD	FE_DOWNWARD
+    FE_UPWARD = 0x3
+#define FE_UPWARD	FE_UPWARD
+  };
+
+
+typedef unsigned int fexcept_t;
+typedef unsigned int fenv_t;
+
+/* If the default argument is used we use this value.  */
+#define FE_DFL_ENV	((__const fenv_t *) -1)
diff --git a/sysdeps/riscv/bits/ipctypes.h b/sysdeps/riscv/bits/ipctypes.h
new file mode 100644
index 0000000..0956e7d
--- /dev/null
+++ b/sysdeps/riscv/bits/ipctypes.h
@@ -0,0 +1,32 @@
+/* bits/ipctypes.h -- Define some types used by SysV IPC/MSG/SHM.  MIPS version
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ * Never include <bits/ipctypes.h> directly.
+ */
+
+#ifndef _BITS_IPCTYPES_H
+#define _BITS_IPCTYPES_H	1
+
+#include <bits/types.h>
+
+typedef __SLONG32_TYPE __ipc_pid_t;
+
+
+#endif /* bits/ipctypes.h */
diff --git a/sysdeps/riscv/bits/link.h b/sysdeps/riscv/bits/link.h
new file mode 100644
index 0000000..f216ebd
--- /dev/null
+++ b/sysdeps/riscv/bits/link.h
@@ -0,0 +1,76 @@
+/* Copyright (C) 2005, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_LINK_H
+# error "Never include <bits/link.h> directly; use <link.h> instead."
+#endif
+
+typedef struct La_mips_64_regs
+{
+  unsigned long lr_reg[8]; /* $a0 through $a7 */
+  double lr_fpreg[8]; /* $f4 throgh $f11 */
+  unsigned long lr_ra;
+  unsigned long lr_sp;
+} La_mips_64_regs;
+
+/* Return values for calls from PLT on MIPS.  */
+typedef struct La_mips_64_retval
+{
+  unsigned long lrv_v0;
+  unsigned long lrv_v1;
+  double lrv_fv0;
+  double lrv_fv1;
+} La_mips_64_retval;
+
+__BEGIN_DECLS
+
+#if _RISCV_SIM == _ABI32
+
+extern Elf32_Addr la_mips_n32_gnu_pltenter (Elf32_Sym *__sym, unsigned int __ndx,
+					    uintptr_t *__refcook,
+					    uintptr_t *__defcook,
+					    La_mips_64_regs *__regs,
+					    unsigned int *__flags,
+					    const char *__symname,
+					    long int *__framesizep);
+extern unsigned int la_mips_n32_gnu_pltexit (Elf32_Sym *__sym, unsigned int __ndx,
+					     uintptr_t *__refcook,
+					     uintptr_t *__defcook,
+					     const La_mips_64_regs *__inregs,
+					     La_mips_64_retval *__outregs,
+					     const char *__symname);
+
+#else
+
+extern Elf64_Addr la_mips_n64_gnu_pltenter (Elf64_Sym *__sym, unsigned int __ndx,
+					    uintptr_t *__refcook,
+					    uintptr_t *__defcook,
+					    La_mips_64_regs *__regs,
+					    unsigned int *__flags,
+					    const char *__symname,
+					    long int *__framesizep);
+extern unsigned int la_mips_n64_gnu_pltexit (Elf64_Sym *__sym, unsigned int __ndx,
+					     uintptr_t *__refcook,
+					     uintptr_t *__defcook,
+					     const La_mips_64_regs *__inregs,
+					     La_mips_64_retval *__outregs,
+					     const char *__symname);
+
+#endif
+
+__END_DECLS
diff --git a/sysdeps/riscv/bits/linkmap.h b/sysdeps/riscv/bits/linkmap.h
new file mode 100644
index 0000000..a6df782
--- /dev/null
+++ b/sysdeps/riscv/bits/linkmap.h
@@ -0,0 +1,4 @@
+struct link_map_machine
+  {
+    ElfW(Addr) plt; /* Address of .plt */
+  };
diff --git a/sysdeps/riscv/bits/mathdef.h b/sysdeps/riscv/bits/mathdef.h
new file mode 100644
index 0000000..1fef80f
--- /dev/null
+++ b/sysdeps/riscv/bits/mathdef.h
@@ -0,0 +1,45 @@
+/* Copyright (C) 1997, 1998, 1999, 2000, 2002, 2003, 2004, 2007
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _MATH_H && !defined _COMPLEX_H
+# error "Never use <bits/mathdef.h> directly; include <math.h> instead"
+#endif
+
+#include <sgidefs.h>
+
+#if defined  __USE_ISOC99 && defined _MATH_H && !defined _MATH_H_MATHDEF
+# define _MATH_H_MATHDEF	1
+
+/* MIPS has `float' and `double' operations.  */
+typedef float float_t;		/* `float' expressions are evaluated as
+				   `float'.  */
+typedef double double_t;	/* `double' expressions are evaluated as
+				   `double'.  */
+
+/* The values returned by `ilogb' for 0 and NaN respectively.  */
+# define FP_ILOGB0	(-2147483647)
+# define FP_ILOGBNAN	2147483647
+
+#endif	/* ISO C99 */
+
+#if ! defined __NO_LONG_DOUBLE_MATH
+/* Signal that we do not really have a `long double'.  This disables the
+   declaration of all the `long double' function variants.  */
+# define __NO_LONG_DOUBLE_MATH	1
+#endif
diff --git a/sysdeps/riscv/bits/nan.h b/sysdeps/riscv/bits/nan.h
new file mode 100644
index 0000000..baaaa55
--- /dev/null
+++ b/sysdeps/riscv/bits/nan.h
@@ -0,0 +1,56 @@
+/* `NAN' constant for IEEE 754 machines.
+   Copyright (C) 1992, 1996, 1997, 1999, 2002, 2004
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _MATH_H
+# error "Never use <bits/nan.h> directly; include <math.h> instead."
+#endif
+
+
+/* IEEE Not A Number (QNaN). Note that MIPS has the QNaN and SNaN patterns
+   reversed compared to most other architectures. The IEEE spec left
+   the definition of this open to implementations, and for MIPS the top
+   bit of the mantissa must be SET to indicate a SNaN.  */
+
+#if __GNUC_PREREQ(3,3)
+
+# define NAN	(__builtin_nanf(""))
+
+#elif defined __GNUC__
+
+# define NAN \
+  (__extension__                                                            \
+   ((union { unsigned __l __attribute__((__mode__(__SI__))); float __d; })  \
+    { __l: 0x7fbfffffUL }).__d)
+
+#else
+
+# include <endian.h>
+
+# if __BYTE_ORDER == __BIG_ENDIAN
+#  define __nan_bytes		{ 0x7f, 0xbf, 0xff, 0xff }
+# endif
+# if __BYTE_ORDER == __LITTLE_ENDIAN
+#  define __nan_bytes		{ 0xff, 0xff, 0xbf, 0x7f }
+# endif
+
+static union { unsigned char __c[4]; float __d; } __nan_union = { __nan_bytes };
+# define NAN	(__nan_union.__d)
+
+#endif	/* GCC.  */
diff --git a/sysdeps/riscv/bits/setjmp.h b/sysdeps/riscv/bits/setjmp.h
new file mode 100644
index 0000000..52e2d3d
--- /dev/null
+++ b/sysdeps/riscv/bits/setjmp.h
@@ -0,0 +1,43 @@
+/* Define the machine-dependent type `jmp_buf'.  RISC-V version.
+   Copyright (C) 1992,1993,1995,1997,2000,2002,2003,2004,2005,2006
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _RISCV_BITS_SETJMP_H
+#define _RISCV_BITS_SETJMP_H
+
+typedef struct __jmp_buf_internal_tag
+  {
+    /* Program counter.  */
+    long __pc;
+    /* Callee-saved registers. */
+    long __regs[12];
+    /* Stack pointer.  */
+    long __sp;
+    /* Thread pointer. */
+    long __tp;
+    /* Floating point status register.  */
+    long __fsr;
+
+    /* Callee-saved floating point registers.
+       Note that there are an even number of preceding words in this struct,
+       so no padding will be inserted before __fpregs, even for RV32. */
+    double __fpregs[16];
+  } __jmp_buf[1];
+
+#endif /* _RISCV_BITS_SETJMP_H */
diff --git a/sysdeps/riscv/bits/string.h b/sysdeps/riscv/bits/string.h
new file mode 100644
index 0000000..dbd3051
--- /dev/null
+++ b/sysdeps/riscv/bits/string.h
@@ -0,0 +1,57 @@
+/* This file should provide inline versions of string functions.
+
+   Surround GCC-specific parts with #ifdef __GNUC__, and use `__extern_inline'.
+
+   This file should define __STRING_INLINES if functions are actually defined
+   as inlines.  */
+
+#ifndef _BITS_STRING_H
+#define _BITS_STRING_H	1
+
+#define _STRING_ARCH_unaligned   0
+
+#if defined(__GNUC__) && !defined(__cplusplus)
+
+static inline unsigned long __libc_detect_null(unsigned long w)
+{
+  unsigned long mask = 0x7f7f7f7f;
+  if (sizeof(long) == 8)
+    mask = ((mask << 16) << 16) | mask;
+  return ~(((w & mask) + mask) | w | mask);
+}
+
+#define _HAVE_STRING_ARCH_memcpy 1
+#define __use_memcpy_align(k, d, s, n) \
+  (__builtin_constant_p(n) && (n) % (k) == 0 && (n) <= 64 && \
+   __alignof__(*(d)) >= (k) && __alignof__(*(s)) >= (k))
+#define memcpy(d, s, n) \
+  (__use_memcpy_align(8, d, s, n) ? __memcpy_align8(d, s, n) : \
+   __use_memcpy_align(4, d, s, n) ? __memcpy_align4(d, s, n) : \
+   __memcpy_g(d, s, n))
+
+#define __declare_memcpy_align(size, type) \
+  static inline void *__memcpy_align ## size(void *__restrict __dest, \
+                        __const void *__restrict __src, size_t __n) { \
+    type *__d = (type*)__dest; \
+    const type *__s = (const type*)__src, *__e = (const type*)(__src + __n); \
+    while (__s < __e) { \
+      type __t = *__s; \
+      __d++, __s++; \
+      *(__d-1) = __t; \
+    } \
+    return __dest; \
+  }
+__declare_memcpy_align(8, long long)
+__declare_memcpy_align(4, int)
+
+#ifdef _LIBC
+extern void *__memcpy_g (void *__restrict __dest,
+                         __const void *__restrict __src, size_t __n);
+libc_hidden_proto (__memcpy_g)
+#else
+# define __memcpy_g memcpy
+#endif
+
+#endif /* __GNUC__ && !__cplusplus */
+
+#endif /* bits/string.h */
diff --git a/sysdeps/riscv/bits/wordsize.h b/sysdeps/riscv/bits/wordsize.h
new file mode 100644
index 0000000..f956c87
--- /dev/null
+++ b/sysdeps/riscv/bits/wordsize.h
@@ -0,0 +1,22 @@
+/* Copyright (C) 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define __WORDSIZE	_RISCV_SZPTR
+#if _RISCV_SIM == _ABI64
+# define __WORDSIZE_COMPAT32	1
+#endif
diff --git a/sysdeps/riscv/bsd-_setjmp.c b/sysdeps/riscv/bsd-_setjmp.c
new file mode 100644
index 0000000..0d41310
--- /dev/null
+++ b/sysdeps/riscv/bsd-_setjmp.c
@@ -0,0 +1 @@
+/* _setjmp is implemented in setjmp.S */
diff --git a/sysdeps/riscv/bsd-setjmp.c b/sysdeps/riscv/bsd-setjmp.c
new file mode 100644
index 0000000..ee7c5e3
--- /dev/null
+++ b/sysdeps/riscv/bsd-setjmp.c
@@ -0,0 +1 @@
+/* setjmp is implemented in setjmp.S */
diff --git a/sysdeps/riscv/configure b/sysdeps/riscv/configure
new file mode 100644
index 0000000..7280dbb
--- /dev/null
+++ b/sysdeps/riscv/configure
@@ -0,0 +1,87 @@
+
+# as_fn_set_status STATUS
+# -----------------------
+# Set $? to STATUS, without forking.
+as_fn_set_status ()
+{
+  return $1
+} # as_fn_set_status
+
+# as_fn_exit STATUS
+# -----------------
+# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
+as_fn_exit ()
+{
+  set +e
+  as_fn_set_status $1
+  exit $1
+} # as_fn_exit
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+
+
+  as_lineno_1=$LINENO as_lineno_1a=$LINENO
+  as_lineno_2=$LINENO as_lineno_2a=$LINENO
+  eval 'test "x$as_lineno_1'$as_run'" != "x$as_lineno_2'$as_run'" &&
+  test "x`expr $as_lineno_1'$as_run' + 1`" = "x$as_lineno_2'$as_run'"' || {
+  # Blame Lee E. McMahon (1931-1989) for sed's syntax.  :-)
+  sed -n '
+    p
+    /[$]LINENO/=
+  ' <$as_myself |
+    sed '
+      s/[$]LINENO.*/&-/
+      t lineno
+      b
+      :lineno
+      N
+      :loop
+      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
+      t loop
+      s/-\n.*//
+    ' >$as_me.lineno &&
+  chmod +x "$as_me.lineno" ||
+    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensitive to this).
+  . "./$as_me.lineno"
+  # Exit status is that of the last command.
+  exit
+}
+
+# This file is generated from configure.in by Autoconf.  DO NOT EDIT!
+ # Local configure fragment for sysdeps/riscv/elf.
+
+$as_echo "#define PI_STATIC_AND_HIDDEN 1" >>confdefs.h
+
diff --git a/sysdeps/riscv/configure.in b/sysdeps/riscv/configure.in
new file mode 100644
index 0000000..34f62d4
--- /dev/null
+++ b/sysdeps/riscv/configure.in
@@ -0,0 +1,4 @@
+GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
+# Local configure fragment for sysdeps/riscv/elf.
+
+AC_DEFINE(PI_STATIC_AND_HIDDEN)
diff --git a/sysdeps/riscv/dl-dtprocnum.h b/sysdeps/riscv/dl-dtprocnum.h
new file mode 100644
index 0000000..adf8dfa
--- /dev/null
+++ b/sysdeps/riscv/dl-dtprocnum.h
@@ -0,0 +1,33 @@
+/* Configuration of lookup functions.  MIPS version.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Number of local global offset table entries.  */
+#define DT_RISCV_LOCAL_GOTNO	0x70000000
+
+/* Number of entries in the .dynsym section.  */
+#define DT_RISCV_SYMTABNO	0x70000001
+
+/* Index of first dynamic symbol in global offset table.  */
+#define DT_RISCV_GOTSYM		0x70000002
+
+/* Address of the base of the PLTGOT.  */
+#define DT_RISCV_PLTGOT         0x70000003
+
+/* Number of extra dynamic section entries for this architecture. */
+#define DT_THISPROCNUM	4
diff --git a/sysdeps/riscv/dl-machine.h b/sysdeps/riscv/dl-machine.h
new file mode 100644
index 0000000..dc56c01
--- /dev/null
+++ b/sysdeps/riscv/dl-machine.h
@@ -0,0 +1,466 @@
+/* Machine-dependent ELF dynamic relocation inline functions.  MIPS version.
+   Copyright (C) 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Kazumoto Kojima <kkojima@info.kanagawa-u.ac.jp>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*  FIXME: Profiling of shared libraries is not implemented yet.  */
+#ifndef dl_machine_h
+#define dl_machine_h
+
+#define ELF_MACHINE_NAME "RISC-V"
+
+/* Relocs. */
+#define R_RISCV_COPY         24
+#define R_RISCV_JUMP_SLOT    25
+#define R_RISCV_TLS_DTPMOD32 38
+#define R_RISCV_TLS_DTPREL32 39
+#define R_RISCV_TLS_DTPMOD64 40
+#define R_RISCV_TLS_DTPREL64 41
+#define R_RISCV_TLS_TPREL32  47
+#define R_RISCV_TLS_TPREL64  48
+
+#include <entry.h>
+
+#ifndef ENTRY_POINT
+#error ENTRY_POINT needs to be defined for MIPS.
+#endif
+
+#include <sys/asm.h>
+#include <dl-tls.h>
+
+#ifndef _RTLD_PROLOGUE
+# define _RTLD_PROLOGUE(entry)						\
+	".globl\t" __STRING(entry) "\n\t"				\
+	".type\t" __STRING(entry) ", @function\n"			\
+	__STRING(entry) ":\n\t"
+#endif
+
+#ifndef _RTLD_EPILOGUE
+# define _RTLD_EPILOGUE(entry)						\
+	".size\t" __STRING(entry) ", . - " __STRING(entry) "\n\t"
+#endif
+
+/* A reloc type used for ld.so cmdline arg lookups to reject PLT entries.
+   This only makes sense on MIPS when using PLTs, so choose the
+   PLT relocation (not encountered when not using PLTs).  */
+#define ELF_MACHINE_JMP_SLOT			R_RISCV_JUMP_SLOT
+#define elf_machine_type_class(type)				\
+  ((ELF_RTYPE_CLASS_PLT * ((type) == ELF_MACHINE_JMP_SLOT	\
+     || (_RISCV_SZPTR == 32 && (type) == R_RISCV_TLS_DTPREL32)	\
+     || (_RISCV_SZPTR == 32 && (type) == R_RISCV_TLS_DTPMOD32)	\
+     || (_RISCV_SZPTR == 32 && (type) == R_RISCV_TLS_TPREL32)	\
+     || (_RISCV_SZPTR == 64 && (type) == R_RISCV_TLS_DTPREL64)	\
+     || (_RISCV_SZPTR == 64 && (type) == R_RISCV_TLS_DTPMOD64)	\
+     || (_RISCV_SZPTR == 64 && (type) == R_RISCV_TLS_TPREL64)))	\
+   | (ELF_RTYPE_CLASS_COPY * ((type) == R_RISCV_COPY)))
+
+#define ELF_MACHINE_NO_REL 0
+#define ELF_MACHINE_NO_RELA 1
+
+/* Translate a processor specific dynamic tag to the index
+   in l_info array.  */
+#define DT_RISCV(x) (DT_RISCV_##x - DT_LOPROC + DT_NUM)
+
+#define ELF_MACHINE_DEBUG_SETUP(l,r)
+
+/* Return nonzero iff ELF header is compatible with the running host.  */
+static inline int __attribute_used__
+elf_machine_matches_host (const ElfW(Ehdr) *ehdr)
+{
+  return 1;
+}
+
+/* Return the link-time address of _DYNAMIC.  Conveniently, this is the
+   first element of the GOT.  This must be inlined in a function which
+   uses global data.  */
+static inline ElfW(Addr)
+elf_machine_dynamic (void)
+{
+  extern ElfW(Addr) _GLOBAL_OFFSET_TABLE_ __attribute__ ((visibility("hidden")));
+  return _GLOBAL_OFFSET_TABLE_;
+}
+
+#define STRINGXP(X) __STRING(X)
+#define STRINGXV(X) STRINGV_(X)
+#define STRINGV_(...) # __VA_ARGS__
+
+/* Return the run-time load address of the shared object.  */
+static inline ElfW(Addr)
+elf_machine_load_address (void)
+{
+  /* Subtract the link-time address of _DYNAMIC from its runtime address. */
+  extern ElfW(Dyn) _DYNAMIC[] __attribute__ ((visibility("hidden")));
+  return (ElfW(Addr))((char*)&_DYNAMIC - elf_machine_dynamic ());
+}
+
+/* Initial entry point code for the dynamic linker.
+   The C function `_dl_start' is the real entry point;
+   its return value is the user program's entry point. */
+
+#define RTLD_START asm (\
+	".text\n\
+	" _RTLD_PROLOGUE(ENTRY_POINT) "\
+	# Store &_DYNAMIC in the first entry of the GOT.\n\
+	la a0, _DYNAMIC\n\
+	" STRINGXP(REG_S) " a0, _GLOBAL_OFFSET_TABLE_, a1\n\
+	move a0, sp\n\
+	jal _dl_start\n\
+	# Stash user entry point in s0.\n\
+	move s0, v0\n\
+	# See if we were run as a command with the executable file\n\
+	# name as an extra leading argument.\n\
+	lw v0, _dl_skip_args\n\
+	# Load the original argument count.\n\
+	" STRINGXP(REG_L) " a1, 0(sp)\n\
+	# Subtract _dl_skip_args from it.\n\
+	sub a1, a1, v0\n\
+	# Adjust the stack pointer to skip _dl_skip_args words.\n\
+	sll v0, v0, " STRINGXP (PTRLOG) "\n\
+	add sp, sp, v0\n\
+	# Save back the modified argument count.\n\
+	" STRINGXP(REG_S) " a1, 0(sp)\n\
+	# Call _dl_init (struct link_map *main_map, int argc, char **argv, char **env) \n\
+	" STRINGXP(REG_L) " a0, _rtld_local\n\
+	add a2, sp, " STRINGXP (SZREG) "\n\
+	sll a3, a1, " STRINGXP (PTRLOG) "\n\
+	add a3, a3, a2\n\
+	add a3, a3, " STRINGXP (SZREG) "\n\
+	# Call the function to run the initializers.\n\
+	jal _dl_init_internal\n\
+	# Pass our finalizer function to the user in v0 as per ELF ABI.\n\
+	lla v0, _dl_fini\n\
+	# Jump to the user entry point.\n\
+	jr s0\n\
+	" _RTLD_EPILOGUE(ENTRY_POINT) "\
+	.previous" \
+);
+
+/* Names of the architecture-specific auditing callback functions.  */
+# ifdef __riscv64
+#  define ARCH_LA_PLTENTER mips_n64_gnu_pltenter
+#  define ARCH_LA_PLTEXIT mips_n64_gnu_pltexit
+# else
+#  define ARCH_LA_PLTENTER mips_n32_gnu_pltenter
+#  define ARCH_LA_PLTEXIT mips_n32_gnu_pltexit
+# endif
+
+/* Bias .got.plt entry by the offset requested by the PLT header. */
+#define elf_machine_plt_value(map, reloc, value) (value)
+#define elf_machine_fixup_plt(map, t, reloc, reloc_addr, value) \
+  (*(ElfW(Addr) *)(reloc_addr) = (value))
+
+#endif /* !dl_machine_h */
+
+#ifdef RESOLVE_MAP
+
+/* Perform a relocation described by R_INFO at the location pointed to
+   by RELOC_ADDR.  SYM is the relocation symbol specified by R_INFO and
+   MAP is the object containing the reloc.  */
+
+auto inline void
+__attribute__ ((always_inline))
+elf_machine_rel (struct link_map *map, const ElfW(Rel) *reloc,
+		 const ElfW(Sym) *sym, const struct r_found_version *version,
+		 void *const reloc_addr, int skip_ifunc)
+{
+  ElfW(Addr) r_info = reloc->r_info;
+  const unsigned long int r_type = ELFW(R_TYPE) (r_info);
+  ElfW(Addr) *addr_field = (ElfW(Addr) *) reloc_addr;
+  const ElfW(Sym) *const refsym = sym;
+  struct link_map *sym_map = RESOLVE_MAP (&sym, version, r_type);
+
+#if !defined RTLD_BOOTSTRAP && !defined SHARED
+  /* This is defined in rtld.c, but nowhere in the static libc.a;
+     make the reference weak so static programs can still link.  This
+     declaration cannot be done when compiling rtld.c (i.e.  #ifdef
+     RTLD_BOOTSTRAP) because rtld.c contains the common defn for
+     _dl_rtld_map, which is incompatible with a weak decl in the same
+     file.  */
+  weak_extern (GL(dl_rtld_map));
+#endif
+
+  switch (r_type)
+    {
+#if defined (USE_TLS) && !defined (RTLD_BOOTSTRAP)
+    case _RISCV_SIM == _ABI64 ? R_MIPS_TLS_DTPMOD64 : R_MIPS_TLS_DTPMOD32:
+      if (sym_map)
+	*addr_field = sym_map->l_tls_modid;
+      break;
+
+    case _RISCV_SIM == _ABI64 ? R_MIPS_TLS_DTPREL64 : R_MIPS_TLS_DTPREL32:
+      if (sym)
+	*addr_field += TLS_DTPREL_VALUE (sym);
+      break;
+
+    case _RISCV_SIM == _ABI64 ? R_MIPS_TLS_TPREL64 : R_MIPS_TLS_TPREL32:
+      if (sym)
+	{
+	  CHECK_STATIC_TLS (map, sym_map);
+	  *addr_field += TLS_TPREL_VALUE (sym_map, sym);
+	}
+      break;
+#endif
+
+    case R_MIPS_REL32:
+      {
+	int symidx = ELFW(R_SYM) (r_info);
+
+	if (symidx)
+	  {
+	    const ElfW(Word) gotsym
+	      = (const ElfW(Word)) map->l_info[DT_RISCV (GOTSYM)]->d_un.d_val;
+
+	    if ((ElfW(Word))symidx < gotsym)
+	      {
+		/* This wouldn't work for a symbol imported from other
+		   libraries for which there's no GOT entry, but MIPS
+		   requires every symbol referenced in a dynamic
+		   relocation to have a GOT entry in the primary GOT,
+		   so we only get here for locally-defined symbols.
+		   For section symbols, we should *NOT* be adding
+		   sym->st_value (per the definition of the meaning of
+		   S in reloc expressions in the ELF64 MIPS ABI),
+		   since it should have already been added to
+		   reloc_value by the linker, but older versions of
+		   GNU ld didn't add it, and newer versions don't emit
+		   useless relocations to section symbols any more, so
+		   it is safe to keep on adding sym->st_value, even
+		   though it's not ABI compliant.  Some day we should
+		   bite the bullet and stop doing this.  */
+#ifndef RTLD_BOOTSTRAP
+		if (map != &GL(dl_rtld_map))
+#endif
+		  if (sym->st_value + map->l_addr)
+		    *addr_field += sym->st_value + map->l_addr;
+	      }
+	    else
+	      {
+#ifndef RTLD_BOOTSTRAP
+		const ElfW(Addr) *got
+		  = (const ElfW(Addr) *) D_PTR (map, l_info[DT_PLTGOT]);
+		const ElfW(Word) local_gotno
+		  = (const ElfW(Word))
+		    map->l_info[DT_RISCV (LOCAL_GOTNO)]->d_un.d_val;
+
+		*addr_field += got[symidx + local_gotno - gotsym];
+#endif
+	      }
+	  }
+	else
+#ifndef RTLD_BOOTSTRAP
+	  if (map != &GL(dl_rtld_map))
+#endif
+	    if (map->l_addr)
+	      *addr_field += map->l_addr;
+      }
+      break;
+
+    case R_RISCV_JUMP_SLOT:
+      {
+	*addr_field = sym_map == NULL ? 0 : sym_map->l_addr + sym->st_value;
+	break;
+      }
+
+    case R_RISCV_COPY:
+      {
+	if (__builtin_expect (sym == NULL, 0))
+	  /* This can happen in trace mode if an object could not be
+	     found.  */
+	  break;
+
+	size_t size = sym->st_size;
+	void *value = (void *)(sym_map ? sym_map->l_addr + sym->st_value : 0);
+
+	if (__builtin_expect (sym->st_size != refsym->st_size, 0))
+	  {
+	    const char *strtab = (const void *) D_PTR (map, l_info[DT_STRTAB]);
+	    if (sym->st_size > refsym->st_size)
+	      size = refsym->st_size;
+	    if (sym->st_size > refsym->st_size || GLRO(dl_verbose))
+	      _dl_error_printf ("\
+  %s: Symbol `%s' has different size in shared object, consider re-linking\n",
+				rtld_progname ?: "<program name unknown>",
+				strtab + refsym->st_name);
+	  }
+
+	memcpy (reloc_addr, value, size);
+	break;
+      }
+
+    case R_MIPS_NONE:
+      break;
+
+    default:
+      _dl_reloc_bad_type (map, r_type, 0);
+      break;
+    }
+}
+
+auto inline void
+__attribute__((always_inline))
+elf_machine_rel_relative (ElfW(Addr) l_addr, const ElfW(Rel) *reloc,
+			  void *const reloc_addr)
+{
+  /* XXX Nothing to do.  There is no relative relocation, right?  */
+}
+
+auto inline void
+__attribute__((always_inline))
+elf_machine_lazy_rel (struct link_map *map, ElfW(Addr) l_addr,
+		      const ElfW(Rel) *reloc, int skip_ifunc)
+{
+  ElfW(Addr) *const reloc_addr = (void *) (l_addr + reloc->r_offset);
+  const unsigned int r_type = ELFW(R_TYPE) (reloc->r_info);
+  /* Check for unexpected PLT reloc type.  */
+  if (__builtin_expect (r_type == R_RISCV_JUMP_SLOT, 1))
+    {
+      if (__builtin_expect (map->l_mach.plt, 0) == 0)
+	{
+	  /* Nothing is required here since we only support lazy
+	     relocation in executables.  */
+	}
+      else
+	*reloc_addr = map->l_mach.plt;
+    }
+  else
+    _dl_reloc_bad_type (map, r_type, 1);
+}
+
+/* Relocate GOT. */
+auto inline void
+__attribute__((always_inline))
+elf_machine_got_rel (struct link_map *map, int lazy)
+{
+  ElfW(Addr) *got;
+  ElfW(Sym) *sym;
+  const ElfW(Half) *vernum;
+  int i, n, symidx;
+
+#ifdef RTLD_BOOTSTRAP
+# define RESOLVE_GOTSYM(sym,vernum,sym_index,reloc)			  \
+    (bootstrap_map.l_addr + sym->st_value)
+#else
+# define RESOLVE_GOTSYM(sym,vernum,sym_index,reloc)			  \
+    ({									  \
+      const ElfW(Sym) *ref = sym;					  \
+      const struct r_found_version *version				  \
+        = vernum ? &map->l_versions[vernum[sym_index] & 0x7fff] : NULL;	  \
+      struct link_map *sym_map;						  \
+      sym_map = RESOLVE_MAP (&ref, version, reloc);			  \
+      ref ? sym_map->l_addr + ref->st_value : 0;			  \
+    })
+#endif
+
+  if (map->l_info[VERSYMIDX (DT_VERSYM)] != NULL)
+    vernum = (const void *) D_PTR (map, l_info[VERSYMIDX (DT_VERSYM)]);
+  else
+    vernum = NULL;
+
+  got = (ElfW(Addr) *) D_PTR (map, l_info[DT_PLTGOT]);
+
+  n = map->l_info[DT_RISCV (LOCAL_GOTNO)]->d_un.d_val;
+  /* The dynamic linker's local got entries have already been relocated.  */
+#ifndef RTLD_BOOTSTRAP
+  if (map != &GL(dl_rtld_map))
+#endif
+    {
+      /* got[0] and got[1] are reserved. */
+      i = 2;
+
+      /* Add the run-time displacement to all local got entries if
+         needed.  */
+      if (__builtin_expect (map->l_addr != 0, 0))
+	{
+	  while (i < n)
+	    got[i++] += map->l_addr;
+	}
+    }
+
+  /* Handle global got entries. */
+  got += n;
+  /* Keep track of the symbol index.  */
+  symidx = map->l_info[DT_RISCV (GOTSYM)]->d_un.d_val;
+  sym = (ElfW(Sym) *) D_PTR (map, l_info[DT_SYMTAB]) + symidx;
+  i = map->l_info[DT_RISCV (SYMTABNO)]->d_un.d_val - symidx;
+
+  /* This loop doesn't handle Quickstart.  */
+  while (i--)
+    {
+      if (sym->st_shndx == SHN_UNDEF || sym->st_shndx == SHN_COMMON)
+	*got = RESOLVE_GOTSYM (sym, vernum, symidx, R_MIPS_32);
+      else if (ELFW(ST_TYPE) (sym->st_info) == STT_FUNC
+	       && *got != sym->st_value)
+	{
+	  if (lazy)
+	    *got += map->l_addr;
+	  else
+	    /* This is a lazy-binding stub, so we don't need the
+	       canonical address.  */
+	    *got = RESOLVE_GOTSYM (sym, vernum, symidx, R_RISCV_JUMP_SLOT);
+	}
+      else if (ELFW(ST_TYPE) (sym->st_info) == STT_SECTION)
+	{
+	  if (sym->st_other == 0)
+	    *got += map->l_addr;
+	}
+      else
+	*got = RESOLVE_GOTSYM (sym, vernum, symidx, R_MIPS_32);
+
+      ++got;
+      ++sym;
+      ++symidx;
+    }
+
+#undef RESOLVE_GOTSYM
+}
+
+/* Set up the loaded object described by L so its stub function
+   will jump to the on-demand fixup code __dl_runtime_resolve.  */
+
+auto inline int
+__attribute__((always_inline))
+elf_machine_runtime_setup (struct link_map *l, int lazy, int profile)
+{
+  /* Relocate global offset table.  */
+  elf_machine_got_rel (l, lazy);
+
+#ifndef RTLD_BOOTSTRAP
+  /* If using PLTs, fill in the first two entries of .got.plt.  */
+  if (l->l_info[DT_JMPREL])
+    {
+      extern void _dl_runtime_resolve (void);
+      ElfW(Addr) *gotplt = (ElfW(Addr) *) D_PTR (l, l_info[DT_RISCV (PLTGOT)]);
+      /* If a library is prelinked but we have to relocate anyway,
+	 we have to be able to undo the prelinking of .got.plt.
+	 The prelinker saved the address of .plt for us here.  */
+      if (gotplt[1])
+	l->l_mach.plt = gotplt[1] + l->l_addr;
+      gotplt[0] = (ElfW(Addr)) &_dl_runtime_resolve;
+      gotplt[1] = (ElfW(Addr)) l;
+      /* Relocate subsequent .got.plt entries. */
+      if (l->l_addr)
+	for (gotplt += 2; *gotplt; gotplt++)
+	  *gotplt += l->l_addr;
+    }
+#endif
+
+  return lazy;
+}
+
+#endif /* RESOLVE_MAP */
diff --git a/sysdeps/riscv/dl-tls.h b/sysdeps/riscv/dl-tls.h
new file mode 100644
index 0000000..8c77a70
--- /dev/null
+++ b/sysdeps/riscv/dl-tls.h
@@ -0,0 +1,49 @@
+/* Thread-local storage handling in the ELF dynamic linker.  MIPS version.
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+/* Type used for the representation of TLS information in the GOT.  */
+typedef struct
+{
+  unsigned long int ti_module;
+  unsigned long int ti_offset;
+} tls_index;
+
+/* The thread pointer points to the first static TLS block.  */
+#define TLS_TP_OFFSET		0
+
+/* Dynamic thread vector pointers point 0x8000 past the start of each
+   TLS block.  */
+#define TLS_DTV_OFFSET		0x800
+
+/* Compute the value for a GOTTPREL reloc.  */
+#define TLS_TPREL_VALUE(sym_map, sym) \
+  ((sym_map)->l_tls_offset + (sym)->st_value - TLS_TP_OFFSET)
+
+/* Compute the value for a DTPREL reloc.  */
+#define TLS_DTPREL_VALUE(sym) \
+  ((sym)->st_value - TLS_DTV_OFFSET)
+
+extern void *__tls_get_addr (tls_index *ti);
+
+# define GET_ADDR_OFFSET	(ti->ti_offset + TLS_DTV_OFFSET)
+# define __TLS_GET_ADDR(__ti)	(__tls_get_addr (__ti) - TLS_DTV_OFFSET)
+
+/* Value used for dtv entries for which the allocation is delayed.  */
+#define TLS_DTV_UNALLOCATED	((void *) -1l)
diff --git a/sysdeps/riscv/dl-trampoline.S b/sysdeps/riscv/dl-trampoline.S
new file mode 100644
index 0000000..2fdd45a
--- /dev/null
+++ b/sysdeps/riscv/dl-trampoline.S
@@ -0,0 +1,39 @@
+#include <sysdep.h>
+#include <sys/asm.h>
+
+/* Assembler veneer called from the PLT header code for lazy loading.
+   The PLT header passes its own args in t0-t2. */
+
+ENTRY(_dl_runtime_resolve)
+  # Save arguments to stack.
+  addi sp, sp, -10*SZREG
+  REG_S ra, 9*SZREG(sp)
+  REG_S a0, 1*SZREG(sp)
+  REG_S a1, 2*SZREG(sp)
+  REG_S a2, 3*SZREG(sp)
+  REG_S a3, 4*SZREG(sp)
+  REG_S a4, 5*SZREG(sp)
+  REG_S a5, 6*SZREG(sp)
+  REG_S a6, 7*SZREG(sp)
+  REG_S a7, 8*SZREG(sp)
+
+  # Update .got.plt and obtain runtime address of callee.
+  mv a0, t0       # link map
+  slli a1, t1, 1  # reloc offset (== twice the .got.plt offset)
+  jal _dl_fixup
+
+  # Restore arguments from stack.
+  REG_L ra, 9*SZREG(sp)
+  REG_L a0, 1*SZREG(sp)
+  REG_L a1, 2*SZREG(sp)
+  REG_L a2, 3*SZREG(sp)
+  REG_L a3, 4*SZREG(sp)
+  REG_L a4, 5*SZREG(sp)
+  REG_L a5, 6*SZREG(sp)
+  REG_L a6, 7*SZREG(sp)
+  REG_L a7, 8*SZREG(sp)
+  addi sp, sp, 10*SZREG
+
+  # Invoke the callee.
+  jr v0
+END(_dl_runtime_resolve)
diff --git a/sysdeps/riscv/fpu/bits/mathinline.h b/sysdeps/riscv/fpu/bits/mathinline.h
new file mode 100644
index 0000000..3c8a33d
--- /dev/null
+++ b/sysdeps/riscv/fpu/bits/mathinline.h
@@ -0,0 +1,66 @@
+/* Inline math functions for RISC-V.
+   Copyright (C) 2011
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Jakub Jelinek <jakub@redhat.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _MATH_H
+# error "Never use <bits/mathinline.h> directly; include <math.h> instead."
+#endif
+
+#include <bits/wordsize.h>
+
+#ifdef __GNUC__
+
+#if defined __USE_ISOC99
+# undef isgreater
+# undef isgreaterequal
+# undef isless
+# undef islessequal
+# undef islessgreater
+# undef isunordered
+
+# define isgreater(x, y) ((x) > (y))
+# define isgreaterequal(x, y) ((x) >= (y))
+# define isless(x, y) ((x) < (y))
+# define islessequal(x, y) ((x) <= (y))
+# define islessgreater(x, y) (!!(isless(x, y) + isgreater(x, y)))
+# define isunordered(x, y) (((x) == (x)) + ((y) == (y)) < 2)
+
+extern inline int __attribute_used__ __signbit (double __x)
+{
+  union { double __d; long __i[sizeof(double)/sizeof(long)]; } __u;
+  __u.__d = __x;
+  return __u.__i[sizeof(double)/sizeof(long)-1] < 0;
+}
+
+extern inline int __attribute_used__ __signbitf (float __x)
+{
+  union { float __d; int __i; } __u;
+  __u.__d = __x;
+  return __u.__i < 0;
+}
+
+#endif /* __USE_ISOC99 */
+
+#if (!defined __NO_MATH_INLINES || defined __LIBC_INTERNAL_MATH_INLINES) && defined __OPTIMIZE__
+
+/* Nothing yet. */
+
+#endif /* !__NO_MATH_INLINES && __OPTIMIZE__ */
+#endif /* __GNUC__ */
diff --git a/sysdeps/riscv/fpu/fclrexcpt.c b/sysdeps/riscv/fpu/fclrexcpt.c
new file mode 100644
index 0000000..746dad9
--- /dev/null
+++ b/sysdeps/riscv/fpu/fclrexcpt.c
@@ -0,0 +1,29 @@
+/* Clear given exceptions in current floating-point environment.
+   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+feclearexcept (int excepts)
+{
+  asm volatile ("csrc fflags, %0" : : "r"(excepts));
+  return 0;
+}
diff --git a/sysdeps/riscv/fpu/fedisblxcpt.c b/sysdeps/riscv/fpu/fedisblxcpt.c
new file mode 100644
index 0000000..25eaee5
--- /dev/null
+++ b/sysdeps/riscv/fpu/fedisblxcpt.c
@@ -0,0 +1,29 @@
+/* Disable floating-point exceptions.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+fedisableexcept (int excepts)
+{
+  /* FP exceptions never generate traps. */
+  return 0;
+}
diff --git a/sysdeps/riscv/fpu/feenablxcpt.c b/sysdeps/riscv/fpu/feenablxcpt.c
new file mode 100644
index 0000000..761c58d
--- /dev/null
+++ b/sysdeps/riscv/fpu/feenablxcpt.c
@@ -0,0 +1,29 @@
+/* Enable floating-point exceptions.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+feenableexcept (int excepts)
+{
+  /* FP exceptions never generate traps. */
+  return -1;
+}
diff --git a/sysdeps/riscv/fpu/fegetenv.c b/sysdeps/riscv/fpu/fegetenv.c
new file mode 100644
index 0000000..da5d597
--- /dev/null
+++ b/sysdeps/riscv/fpu/fegetenv.c
@@ -0,0 +1,32 @@
+/* Store current floating-point environment.
+   Copyright (C) 1998, 1999, 2000, 2002, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+fegetenv (fenv_t *envp)
+{
+  _FPU_GETCW (*envp);
+
+  /* Success.  */
+  return 0;
+}
+libm_hidden_def (fegetenv)
diff --git a/sysdeps/riscv/fpu/fegetexcept.c b/sysdeps/riscv/fpu/fegetexcept.c
new file mode 100644
index 0000000..bdb4b7d
--- /dev/null
+++ b/sysdeps/riscv/fpu/fegetexcept.c
@@ -0,0 +1,29 @@
+/* Get enabled floating-point exceptions.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+fegetexcept (void)
+{
+  /* FP exceptions never generate traps. */
+  return 0;
+}
diff --git a/sysdeps/riscv/fpu/fegetround.c b/sysdeps/riscv/fpu/fegetround.c
new file mode 100644
index 0000000..47eb92f
--- /dev/null
+++ b/sysdeps/riscv/fpu/fegetround.c
@@ -0,0 +1,30 @@
+/* Return current rounding direction.
+   Copyright (C) 1998 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@arthur.rhein-neckar.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+fegetround (void)
+{
+  int round;
+  _FPU_GETROUND (round);
+  return round;
+}
diff --git a/sysdeps/riscv/fpu/feholdexcpt.c b/sysdeps/riscv/fpu/feholdexcpt.c
new file mode 100644
index 0000000..3d8fa22
--- /dev/null
+++ b/sysdeps/riscv/fpu/feholdexcpt.c
@@ -0,0 +1,32 @@
+/* Store current floating-point environment and clear exceptions.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+feholdexcept (fenv_t *envp)
+{
+  _FPU_GETCW (*envp);
+  _FPU_SETFLAGS (0);
+  return 0;
+}
+
+libm_hidden_def (feholdexcept)
diff --git a/sysdeps/riscv/fpu/fesetenv.c b/sysdeps/riscv/fpu/fesetenv.c
new file mode 100644
index 0000000..e34fdaf
--- /dev/null
+++ b/sysdeps/riscv/fpu/fesetenv.c
@@ -0,0 +1,31 @@
+/* Install given floating-point environment.
+   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+fesetenv (const fenv_t *envp)
+{
+  _FPU_SETCW (envp == FE_DFL_ENV ? 0 : *envp);
+  return 0;
+}
+
+libm_hidden_def (fesetenv)
diff --git a/sysdeps/riscv/fpu/fesetround.c b/sysdeps/riscv/fpu/fesetround.c
new file mode 100644
index 0000000..ad80465
--- /dev/null
+++ b/sysdeps/riscv/fpu/fesetround.c
@@ -0,0 +1,34 @@
+/* Set current rounding direction.
+   Copyright (C) 1998 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@arthur.rhein-neckar.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+fesetround (int round)
+{
+  int fail = round != FE_TONEAREST && round != FE_TOWARDZERO
+	     && round != FE_DOWNWARD && round != FE_UPWARD;
+  if (!fail)
+    _FPU_SETROUND (round);
+  return fail;
+}
+
+libm_hidden_def (fesetround)
diff --git a/sysdeps/riscv/fpu/feupdateenv.c b/sysdeps/riscv/fpu/feupdateenv.c
new file mode 100644
index 0000000..51611cd
--- /dev/null
+++ b/sysdeps/riscv/fpu/feupdateenv.c
@@ -0,0 +1,35 @@
+/* Install given floating-point environment and raise exceptions.
+   Copyright (C) 1998, 1999, 2000, 2002, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+feupdateenv (const fenv_t *envp)
+{
+  fenv_t env = *envp;
+
+  /* rm = 0; rm |= fenv.rm; flags |= fenv.flags */
+  _FPU_SETROUND (0);
+  asm volatile ("csrs fcsr, %0" : : "r"(env));
+
+  return 0;
+}
+libm_hidden_def (feupdateenv)
diff --git a/sysdeps/riscv/fpu/fgetexcptflg.c b/sysdeps/riscv/fpu/fgetexcptflg.c
new file mode 100644
index 0000000..537f5b7
--- /dev/null
+++ b/sysdeps/riscv/fpu/fgetexcptflg.c
@@ -0,0 +1,35 @@
+/* Store current representation for exceptions.
+   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+fegetexceptflag (fexcept_t *flagp, int excepts)
+{
+  fpu_control_t temp;
+
+  /* Get the current exceptions.  */
+  _FPU_GETFLAGS (*flagp);
+  *flagp &= excepts;
+
+  /* Success.  */
+  return 0;
+}
diff --git a/sysdeps/riscv/fpu/fraiseexcpt.c b/sysdeps/riscv/fpu/fraiseexcpt.c
new file mode 100644
index 0000000..2a839d0
--- /dev/null
+++ b/sysdeps/riscv/fpu/fraiseexcpt.c
@@ -0,0 +1,31 @@
+/* Raise given exceptions.
+   Copyright (C) 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+feraiseexcept (int excepts)
+{
+  asm volatile ("csrs fflags, %0" : : "r"(excepts));
+  return 0;
+}
+
+libm_hidden_def (feraiseexcept)
diff --git a/sysdeps/riscv/fpu/fsetexcptflg.c b/sysdeps/riscv/fpu/fsetexcptflg.c
new file mode 100644
index 0000000..c28235a
--- /dev/null
+++ b/sysdeps/riscv/fpu/fsetexcptflg.c
@@ -0,0 +1,32 @@
+/* Set floating-point environment exception handling.
+   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Hartvig Ekner <hartvige@mips.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+fesetexceptflag (const fexcept_t *flagp, int excepts)
+{
+  fexcept_t flags = *flagp;
+  asm volatile ("csrc fflags, %0" : : "r"(excepts));
+  asm volatile ("csrs fflags, %0" : : "r"(flags & excepts));
+
+  return 0;
+}
diff --git a/sysdeps/riscv/fpu/ftestexcept.c b/sysdeps/riscv/fpu/ftestexcept.c
new file mode 100644
index 0000000..8235fa1
--- /dev/null
+++ b/sysdeps/riscv/fpu/ftestexcept.c
@@ -0,0 +1,33 @@
+/* Test exception in current environment.
+   Copyright (C) 1998, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@arthur.rhein-neckar.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+fetestexcept (int excepts)
+{
+  int cw;
+
+  _FPU_GETFLAGS (cw);
+
+  return cw & excepts;
+}
+libm_hidden_def (fetestexcept)
diff --git a/sysdeps/riscv/fpu/libm-test-ulps b/sysdeps/riscv/fpu/libm-test-ulps
new file mode 100644
index 0000000..e69de29
diff --git a/sysdeps/riscv/fpu/s_copysign.c b/sysdeps/riscv/fpu/s_copysign.c
new file mode 100644
index 0000000..32dc5dc
--- /dev/null
+++ b/sysdeps/riscv/fpu/s_copysign.c
@@ -0,0 +1,9 @@
+#include "math.h"
+
+double __copysign(double x, double y)
+{
+  double res;
+  asm ("fsgnj.d %0, %1, %2" : "=f"(res) : "f"(x), "f"(y));
+  return res;
+}
+weak_alias (__copysign, copysign)
diff --git a/sysdeps/riscv/fpu/s_copysignf.c b/sysdeps/riscv/fpu/s_copysignf.c
new file mode 100644
index 0000000..11d493b
--- /dev/null
+++ b/sysdeps/riscv/fpu/s_copysignf.c
@@ -0,0 +1,9 @@
+#include "math.h"
+
+float __copysignf(float x, float y)
+{
+  float res;
+  asm ("fsgnj.s %0, %1, %2" : "=f"(res) : "f"(x), "f"(y));
+  return res;
+}
+weak_alias (__copysignf, copysignf)
diff --git a/sysdeps/riscv/fpu/s_fabs.c b/sysdeps/riscv/fpu/s_fabs.c
new file mode 100644
index 0000000..95f5b28
--- /dev/null
+++ b/sysdeps/riscv/fpu/s_fabs.c
@@ -0,0 +1,9 @@
+#include "math.h"
+
+double __fabs(double x)
+{
+  double res;
+  asm ("fabs.d %0, %1" : "=f"(res) : "f"(x));
+  return res;
+}
+weak_alias (__fabs, fabs)
diff --git a/sysdeps/riscv/fpu/s_fabsf.c b/sysdeps/riscv/fpu/s_fabsf.c
new file mode 100644
index 0000000..9df4ae6
--- /dev/null
+++ b/sysdeps/riscv/fpu/s_fabsf.c
@@ -0,0 +1,9 @@
+#include "math.h"
+
+float __fabsf(float x)
+{
+  float res;
+  asm ("fabs.s %0, %1" : "=f"(res) : "f"(x));
+  return res;
+}
+weak_alias (__fabsf, fabsf)
diff --git a/sysdeps/riscv/fpu/s_fdim.c b/sysdeps/riscv/fpu/s_fdim.c
new file mode 100644
index 0000000..9835f59
--- /dev/null
+++ b/sysdeps/riscv/fpu/s_fdim.c
@@ -0,0 +1,17 @@
+#include <errno.h>
+#include <math.h>
+#include "fpu_control.h"
+
+double __fdim (double x, double y)
+{
+  double diff = x - y;
+  
+  if (x <= y)
+    return 0.0;
+
+  if (__builtin_expect(_FCLASS(diff) & _FCLASS_INF, 0))
+    errno = ERANGE;
+
+  return diff;
+}
+weak_alias (__fdim, fdim)
diff --git a/sysdeps/riscv/fpu/s_fdimf.c b/sysdeps/riscv/fpu/s_fdimf.c
new file mode 100644
index 0000000..480136c
--- /dev/null
+++ b/sysdeps/riscv/fpu/s_fdimf.c
@@ -0,0 +1,17 @@
+#include <errno.h>
+#include <math.h>
+#include "fpu_control.h"
+
+float __fdimf (float x, float y)
+{
+  float diff = x - y;
+  
+  if (x <= y)
+    return 0.0f;
+
+  if (__builtin_expect(_FCLASS(diff) & _FCLASS_INF, 0))
+    errno = ERANGE;
+
+  return diff;
+}
+weak_alias (__fdimf, fdimf)
diff --git a/sysdeps/riscv/fpu/s_finite.c b/sysdeps/riscv/fpu/s_finite.c
new file mode 100644
index 0000000..bf2135b
--- /dev/null
+++ b/sysdeps/riscv/fpu/s_finite.c
@@ -0,0 +1,9 @@
+#include "math.h"
+#include "fpu_control.h"
+
+int __finite(double x)
+{
+  return _FCLASS(x) & ~(_FCLASS_INF | _FCLASS_NAN);
+}
+hidden_def (__finite)
+weak_alias (__finite, finite)
diff --git a/sysdeps/riscv/fpu/s_finitef.c b/sysdeps/riscv/fpu/s_finitef.c
new file mode 100644
index 0000000..6448d2d
--- /dev/null
+++ b/sysdeps/riscv/fpu/s_finitef.c
@@ -0,0 +1,9 @@
+#include "math.h"
+#include "fpu_control.h"
+
+int __finitef(float x)
+{
+  return _FCLASS(x) & ~(_FCLASS_INF | _FCLASS_NAN);
+}
+hidden_def (__finitef)
+weak_alias (__finitef, finitef)
diff --git a/sysdeps/riscv/fpu/s_fma.c b/sysdeps/riscv/fpu/s_fma.c
new file mode 100644
index 0000000..797bc7d
--- /dev/null
+++ b/sysdeps/riscv/fpu/s_fma.c
@@ -0,0 +1,11 @@
+#include <math.h>
+#include <fenv.h>
+#include <ieee754.h>
+
+double __fma (double x, double y, double z)
+{
+  double out;
+  asm volatile ("fmadd.d %0, %1, %2, %3" : "=f"(out) : "f"(x), "f"(y), "f"(z));
+  return out;
+}
+weak_alias (__fma, fma)
diff --git a/sysdeps/riscv/fpu/s_fmaf.c b/sysdeps/riscv/fpu/s_fmaf.c
new file mode 100644
index 0000000..11775f9
--- /dev/null
+++ b/sysdeps/riscv/fpu/s_fmaf.c
@@ -0,0 +1,11 @@
+#include <math.h>
+#include <fenv.h>
+#include <ieee754.h>
+
+float __fmaf (float x, float y, float z)
+{
+  float out;
+  asm volatile ("fmadd.s %0, %1, %2, %3" : "=f"(out) : "f"(x), "f"(y), "f"(z));
+  return out;
+}
+weak_alias (__fmaf, fmaf)
diff --git a/sysdeps/riscv/fpu/s_fmax.c b/sysdeps/riscv/fpu/s_fmax.c
new file mode 100644
index 0000000..8d2e662
--- /dev/null
+++ b/sysdeps/riscv/fpu/s_fmax.c
@@ -0,0 +1,9 @@
+#include <math.h>
+
+double __fmax (double x, double y)
+{
+  double res;
+  asm ("fmax.d %0, %1, %2" : "=f"(res) : "f"(x), "f"(y));
+  return res;
+}
+weak_alias (__fmax, fmax)
diff --git a/sysdeps/riscv/fpu/s_fmaxf.c b/sysdeps/riscv/fpu/s_fmaxf.c
new file mode 100644
index 0000000..aa62172
--- /dev/null
+++ b/sysdeps/riscv/fpu/s_fmaxf.c
@@ -0,0 +1,9 @@
+#include <math.h>
+
+float __fmaxf (float x, float y)
+{
+  float res;
+  asm ("fmax.s %0, %1, %2" : "=f"(res) : "f"(x), "f"(y));
+  return res;
+}
+weak_alias (__fmaxf, fmaxf)
diff --git a/sysdeps/riscv/fpu/s_fmin.c b/sysdeps/riscv/fpu/s_fmin.c
new file mode 100644
index 0000000..e4e37df
--- /dev/null
+++ b/sysdeps/riscv/fpu/s_fmin.c
@@ -0,0 +1,9 @@
+#include <math.h>
+
+double __fmin (double x, double y)
+{
+  double res;
+  asm ("fmin.d %0, %1, %2" : "=f"(res) : "f"(x), "f"(y));
+  return res;
+}
+weak_alias (__fmin, fmin)
diff --git a/sysdeps/riscv/fpu/s_fminf.c b/sysdeps/riscv/fpu/s_fminf.c
new file mode 100644
index 0000000..5d25bc2
--- /dev/null
+++ b/sysdeps/riscv/fpu/s_fminf.c
@@ -0,0 +1,9 @@
+#include <math.h>
+
+float __fminf (float x, float y)
+{
+  float res;
+  asm ("fmin.s %0, %1, %2" : "=f"(res) : "f"(x), "f"(y));
+  return res;
+}
+weak_alias (__fminf, fminf)
diff --git a/sysdeps/riscv/fpu/s_fpclassify.c b/sysdeps/riscv/fpu/s_fpclassify.c
new file mode 100644
index 0000000..2b58c3f
--- /dev/null
+++ b/sysdeps/riscv/fpu/s_fpclassify.c
@@ -0,0 +1,18 @@
+#include <math.h>
+#include "fpu_control.h"
+#include "math_private.h"
+
+int __fpclassify (double x)
+{
+  int cls = _FCLASS(x);
+  if (__builtin_expect(cls & _FCLASS_NORM, _FCLASS_NORM))
+    return FP_NORMAL;
+  if (__builtin_expect(cls & _FCLASS_ZERO, _FCLASS_ZERO))
+    return FP_ZERO;
+  if (__builtin_expect(cls & _FCLASS_SUBNORM, _FCLASS_SUBNORM))
+    return FP_SUBNORMAL;
+  if (__builtin_expect(cls & _FCLASS_INF, _FCLASS_INF))
+    return FP_INFINITE;
+  return FP_NAN;
+}
+libm_hidden_def (__fpclassify)
diff --git a/sysdeps/riscv/fpu/s_fpclassifyf.c b/sysdeps/riscv/fpu/s_fpclassifyf.c
new file mode 100644
index 0000000..fae20fa
--- /dev/null
+++ b/sysdeps/riscv/fpu/s_fpclassifyf.c
@@ -0,0 +1,18 @@
+#include <math.h>
+#include "fpu_control.h"
+#include "math_private.h"
+
+int __fpclassifyf (float x)
+{
+  int cls = _FCLASS(x);
+  if (__builtin_expect(cls & _FCLASS_NORM, _FCLASS_NORM))
+    return FP_NORMAL;
+  if (__builtin_expect(cls & _FCLASS_ZERO, _FCLASS_ZERO))
+    return FP_ZERO;
+  if (__builtin_expect(cls & _FCLASS_SUBNORM, _FCLASS_SUBNORM))
+    return FP_SUBNORMAL;
+  if (__builtin_expect(cls & _FCLASS_INF, _FCLASS_INF))
+    return FP_INFINITE;
+  return FP_NAN;
+}
+libm_hidden_def (__fpclassifyf)
diff --git a/sysdeps/riscv/fpu/s_isinf.c b/sysdeps/riscv/fpu/s_isinf.c
new file mode 100644
index 0000000..339d97f
--- /dev/null
+++ b/sysdeps/riscv/fpu/s_isinf.c
@@ -0,0 +1,10 @@
+#include "math.h"
+#include "fpu_control.h"
+
+int __isinf(double x)
+{
+  int cls = _FCLASS(x);
+  return -((cls & _FCLASS_MINF) ? 1 : 0) | ((cls & _FCLASS_PINF) ? 1 : 0);
+}
+hidden_def (__isinf)
+weak_alias (__isinf, isinf)
diff --git a/sysdeps/riscv/fpu/s_isinff.c b/sysdeps/riscv/fpu/s_isinff.c
new file mode 100644
index 0000000..501342e
--- /dev/null
+++ b/sysdeps/riscv/fpu/s_isinff.c
@@ -0,0 +1,10 @@
+#include "math.h"
+#include "fpu_control.h"
+
+int __isinff(float x)
+{
+  int cls = _FCLASS(x);
+  return -((cls & _FCLASS_MINF) ? 1 : 0) | ((cls & _FCLASS_PINF) ? 1 : 0);
+}
+hidden_def (__isinff)
+weak_alias (__isinff, isinff)
diff --git a/sysdeps/riscv/fpu/s_isnan.c b/sysdeps/riscv/fpu/s_isnan.c
new file mode 100644
index 0000000..dcbb629
--- /dev/null
+++ b/sysdeps/riscv/fpu/s_isnan.c
@@ -0,0 +1,9 @@
+#include "math.h"
+#include "fpu_control.h"
+
+int __isnan(double x)
+{
+  return _FCLASS(x) & _FCLASS_NAN;
+}
+hidden_def (__isnan)
+weak_alias (__isnan, isnan)
diff --git a/sysdeps/riscv/fpu/s_isnanf.c b/sysdeps/riscv/fpu/s_isnanf.c
new file mode 100644
index 0000000..78e9d0c
--- /dev/null
+++ b/sysdeps/riscv/fpu/s_isnanf.c
@@ -0,0 +1,9 @@
+#include "math.h"
+#include "fpu_control.h"
+
+int __isnanf(float x)
+{
+  return _FCLASS(x) & _FCLASS_NAN;
+}
+hidden_def (__isnanf)
+weak_alias (__isnanf, isnanf)
diff --git a/sysdeps/riscv/fpu/s_signbit.c b/sysdeps/riscv/fpu/s_signbit.c
new file mode 100644
index 0000000..5f99c3f
--- /dev/null
+++ b/sysdeps/riscv/fpu/s_signbit.c
@@ -0,0 +1,18 @@
+#include <features.h>
+#undef __USE_EXTERN_INLINES
+#include <math.h>
+#include <stdint.h>
+#include "math_private.h"
+
+int __signbit (double x)
+{
+#ifdef __riscv64
+  int64_t hx;
+  EXTRACT_WORDS64 (hx, x);
+  return hx < 0;
+#else
+  int32_t hx;
+  GET_HIGH_WORD (hx, x);
+  return hx < 0;
+#endif
+}
diff --git a/sysdeps/riscv/fpu/s_signbitf.c b/sysdeps/riscv/fpu/s_signbitf.c
new file mode 100644
index 0000000..6e25688
--- /dev/null
+++ b/sysdeps/riscv/fpu/s_signbitf.c
@@ -0,0 +1,12 @@
+#include <features.h>
+#undef __USE_EXTERN_INLINES
+#include <math.h>
+#include <stdint.h>
+#include "math_private.h"
+
+int __signbitf (float x)
+{
+  int32_t hx;
+  GET_FLOAT_WORD (hx, x);
+  return hx < 0;
+}
diff --git a/sysdeps/riscv/fpu_control.h b/sysdeps/riscv/fpu_control.h
new file mode 100644
index 0000000..4c36db5
--- /dev/null
+++ b/sysdeps/riscv/fpu_control.h
@@ -0,0 +1,92 @@
+/* FPU control word bits.  Mips version.
+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2006, 2008
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Olaf Flebbe and Ralf Baechle.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _FPU_CONTROL_H
+#define _FPU_CONTROL_H
+
+#include <features.h>
+
+#ifdef __riscv_soft_float
+
+#define _FPU_RESERVED 0xffffffff
+#define _FPU_DEFAULT  0x00000000
+typedef unsigned int fpu_control_t;
+#define _FPU_GETCW(cw) 0
+#define _FPU_SETCW(cw) do { } while (0)
+extern fpu_control_t __fpu_control;
+
+#else /* __mips_soft_float */
+
+/* rounding control */
+#define _FPU_RC_NEAREST 0x0
+#define _FPU_RC_ZERO    0x1
+#define _FPU_RC_DOWN    0x2
+#define _FPU_RC_UP      0x3
+
+#define _FPU_RESERVED   0    /* No reserved bits in FSR */
+
+/* The fdlibm code requires strict IEEE double precision arithmetic,
+   and no interrupts for exceptions, rounding to nearest.  */
+
+#define _FPU_DEFAULT  0
+
+/* IEEE:  same as above */
+#define _FPU_IEEE     _FPU_DEFAULT
+
+/* Type of the control word.  */
+typedef unsigned int fpu_control_t __attribute__ ((__mode__ (__SI__)));
+
+/* Macros for accessing the hardware control word.  */
+#define _FPU_GETCW(cw) __asm__ volatile ("frsr %0" : "=r" (cw))
+#define _FPU_GETROUND(cw) __asm__ volatile ("frrm %0" : "=r" (cw))
+#define _FPU_GETFLAGS(cw) __asm__ volatile ("frflags %0" : "=r" (cw))
+#define _FPU_SETCW(cw) __asm__ volatile ("fssr %z0" : : "rJ" (cw))
+#define _FPU_SETROUND(cw) __asm__ volatile ("fsrm %z0" : : "rJ" (cw))
+#define _FPU_SETFLAGS(cw) __asm__ volatile ("fsflags %z0" : : "rJ" (cw))
+
+/* Default control word set at startup.  */
+extern fpu_control_t __fpu_control;
+
+#define _FCLASS(x) ({ int res; \
+  if (sizeof(x) == 4) asm ("fclass.s %0, %1" : "=r"(res) : "f"(x)); \
+  else if (sizeof(x) == 8) asm ("fclass.d %0, %1" : "=r"(res) : "f"(x)); \
+  else abort(); \
+  res; })
+
+#define _FCLASS_MINF     (1<<0)
+#define _FCLASS_MNORM    (1<<1)
+#define _FCLASS_MSUBNORM (1<<2)
+#define _FCLASS_MZERO    (1<<3)
+#define _FCLASS_PZERO    (1<<4)
+#define _FCLASS_PSUBNORM (1<<5)
+#define _FCLASS_PNORM    (1<<6)
+#define _FCLASS_PINF     (1<<7)
+#define _FCLASS_SNAN     (1<<8)
+#define _FCLASS_QNAN     (1<<9)
+#define _FCLASS_ZERO     (_FCLASS_MZERO | _FCLASS_PZERO)
+#define _FCLASS_SUBNORM  (_FCLASS_MSUBNORM | _FCLASS_PSUBNORM)
+#define _FCLASS_NORM     (_FCLASS_MNORM | _FCLASS_PNORM)
+#define _FCLASS_INF      (_FCLASS_MINF | _FCLASS_PINF)
+#define _FCLASS_NAN      (_FCLASS_SNAN | _FCLASS_QNAN)
+
+#endif /* __mips_soft_float */
+
+#endif	/* fpu_control.h */
diff --git a/sysdeps/riscv/gccframe.h b/sysdeps/riscv/gccframe.h
new file mode 100644
index 0000000..ec9311c
--- /dev/null
+++ b/sysdeps/riscv/gccframe.h
@@ -0,0 +1,22 @@
+/* Definition of object in frame unwind info.  mips version.
+   Copyright (C) 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define FIRST_PSEUDO_REGISTER 76
+
+#include <sysdeps/generic/gccframe.h>
diff --git a/sysdeps/riscv/ieee754.h b/sysdeps/riscv/ieee754.h
new file mode 100644
index 0000000..912e088
--- /dev/null
+++ b/sysdeps/riscv/ieee754.h
@@ -0,0 +1,325 @@
+/* Copyright (C) 1992, 1995, 1996, 1999, 2002, 2003
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _IEEE754_H
+
+#define _IEEE754_H 1
+#include <features.h>
+
+#include <endian.h>
+
+#include <float.h>
+
+__BEGIN_DECLS
+
+union ieee754_float
+  {
+    float f;
+
+    /* This is the IEEE 754 single-precision format.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:8;
+	unsigned int mantissa:23;
+#endif				/* Big endian.  */
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+	unsigned int mantissa:23;
+	unsigned int exponent:8;
+	unsigned int negative:1;
+#endif				/* Little endian.  */
+      } ieee;
+
+    /* This format makes it easier to see if a NaN is a signalling NaN.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:8;
+	unsigned int quiet_nan:1;
+	unsigned int mantissa:22;
+#endif				/* Big endian.  */
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+	unsigned int mantissa:22;
+	unsigned int quiet_nan:1;
+	unsigned int exponent:8;
+	unsigned int negative:1;
+#endif				/* Little endian.  */
+      } ieee_nan;
+  };
+
+#define IEEE754_FLOAT_BIAS	0x7f /* Added to exponent.  */
+
+
+union ieee754_double
+  {
+    double d;
+
+    /* This is the IEEE 754 double-precision format.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:11;
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa0:20;
+	unsigned int mantissa1:32;
+#endif				/* Big endian.  */
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+# if	__FLOAT_WORD_ORDER == __BIG_ENDIAN
+	unsigned int mantissa0:20;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+	unsigned int mantissa1:32;
+# else
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:20;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+# endif
+#endif				/* Little endian.  */
+      } ieee;
+
+    /* This format makes it easier to see if a NaN is a signalling NaN.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:11;
+	unsigned int quiet_nan:1;
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa0:19;
+	unsigned int mantissa1:32;
+#else
+# if	__FLOAT_WORD_ORDER == __BIG_ENDIAN
+	unsigned int mantissa0:19;
+	unsigned int quiet_nan:1;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+	unsigned int mantissa1:32;
+# else
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:19;
+	unsigned int quiet_nan:1;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+# endif
+#endif
+      } ieee_nan;
+  };
+
+#define IEEE754_DOUBLE_BIAS	0x3ff /* Added to exponent.  */
+
+#if LDBL_MANT_DIG == 113
+
+union ieee854_long_double
+  {
+    long double d;
+
+    /* This is the IEEE 854 quad-precision format.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:15;
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa0:16;
+	unsigned int mantissa1:32;
+	unsigned int mantissa2:32;
+	unsigned int mantissa3:32;
+#endif				/* Big endian.  */
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa3:32;
+	unsigned int mantissa2:32;
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:16;
+	unsigned int exponent:15;
+	unsigned int negative:1;
+#endif				/* Little endian.  */
+      } ieee;
+
+    /* This format makes it easier to see if a NaN is a signalling NaN.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:15;
+	unsigned int quiet_nan:1;
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa0:15;
+	unsigned int mantissa1:32;
+	unsigned int mantissa2:32;
+	unsigned int mantissa3:32;
+#endif				/* Big endian.  */
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa3:32;
+	unsigned int mantissa2:32;
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:15;
+	unsigned int quiet_nan:1;
+	unsigned int exponent:15;
+	unsigned int negative:1;
+#endif				/* Little endian.  */
+      } ieee_nan;
+  };
+
+#define IEEE854_LONG_DOUBLE_BIAS 0x3fff /* Added to exponent.  */
+
+#elif LDBL_MANT_DIG == 64
+
+union ieee854_long_double
+  {
+    long double d;
+
+    /* This is the IEEE 854 double-extended-precision format.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:15;
+	unsigned int empty:16;
+	unsigned int mantissa0:32;
+	unsigned int mantissa1:32;
+#endif
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+# if	__FLOAT_WORD_ORDER == __BIG_ENDIAN
+	unsigned int exponent:15;
+	unsigned int negative:1;
+	unsigned int empty:16;
+	unsigned int mantissa0:32;
+	unsigned int mantissa1:32;
+# else
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:32;
+	unsigned int exponent:15;
+	unsigned int negative:1;
+	unsigned int empty:16;
+# endif
+#endif
+      } ieee;
+
+    /* This is for NaNs in the IEEE 854 double-extended-precision format.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:15;
+	unsigned int empty:16;
+	unsigned int one:1;
+	unsigned int quiet_nan:1;
+	unsigned int mantissa0:30;
+	unsigned int mantissa1:32;
+#endif
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+# if	__FLOAT_WORD_ORDER == __BIG_ENDIAN
+	unsigned int exponent:15;
+	unsigned int negative:1;
+	unsigned int empty:16;
+	unsigned int mantissa0:30;
+	unsigned int quiet_nan:1;
+	unsigned int one:1;
+	unsigned int mantissa1:32;
+# else
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:30;
+	unsigned int quiet_nan:1;
+	unsigned int one:1;
+	unsigned int exponent:15;
+	unsigned int negative:1;
+	unsigned int empty:16;
+# endif
+#endif
+      } ieee_nan;
+  };
+
+#define IEEE854_LONG_DOUBLE_BIAS 0x3fff
+
+#elif LDBL_MANT_DIG == 53
+
+union ieee854_long_double
+  {
+    long double d;
+
+    /* This is the IEEE 754 double-precision format.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:11;
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa0:20;
+	unsigned int mantissa1:32;
+#endif				/* Big endian.  */
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+# if	__FLOAT_WORD_ORDER == __BIG_ENDIAN
+	unsigned int mantissa0:20;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+	unsigned int mantissa1:32;
+# else
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:20;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+# endif
+#endif				/* Little endian.  */
+      } ieee;
+
+    /* This format makes it easier to see if a NaN is a signalling NaN.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:11;
+	unsigned int quiet_nan:1;
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa0:19;
+	unsigned int mantissa1:32;
+#else
+# if	__FLOAT_WORD_ORDER == __BIG_ENDIAN
+	unsigned int mantissa0:19;
+	unsigned int quiet_nan:1;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+	unsigned int mantissa1:32;
+# else
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:19;
+	unsigned int quiet_nan:1;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+# endif
+#endif
+      } ieee_nan;
+  };
+
+#define IEEE854_LONG_DOUBLE_BIAS	0x3ff /* Added to exponent.  */
+
+#endif /* LDBL_MANT_DIG == 53 */
+
+__END_DECLS
+
+#endif /* ieee754.h */
diff --git a/sysdeps/riscv/jmpbuf-unwind.h b/sysdeps/riscv/jmpbuf-unwind.h
new file mode 100644
index 0000000..bfa1a64
--- /dev/null
+++ b/sysdeps/riscv/jmpbuf-unwind.h
@@ -0,0 +1,46 @@
+/* Copyright (C) 2003, 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <setjmp.h>
+#include <stdint.h>
+#include <unwind.h>
+#include <sysdep.h>
+
+/* Test if longjmp to JMPBUF would unwind the frame
+   containing a local variable at ADDRESS.  */
+#define _JMPBUF_UNWINDS(jmpbuf, address, demangle)		\
+  ((void *) (address) < (void *) demangle ((jmpbuf)[0].__sp))
+
+#define _JMPBUF_CFA_UNWINDS_ADJ(_jmpbuf, _context, _adj) \
+  _JMPBUF_UNWINDS_ADJ (_jmpbuf, (void *) _Unwind_GetCFA (_context), _adj)
+
+static inline uintptr_t __attribute__ ((unused))
+_jmpbuf_sp (__jmp_buf regs)
+{
+  uintptr_t sp = regs[0].__sp;
+#ifdef PTR_DEMANGLE
+  PTR_DEMANGLE (sp);
+#endif
+  return sp;
+}
+
+#define _JMPBUF_UNWINDS_ADJ(_jmpbuf, _address, _adj) \
+  ((uintptr_t) (_address) - (_adj) < _jmpbuf_sp (_jmpbuf) - (_adj))
+
+/* We use the normal longjmp for unwinding.  */
+#define __libc_unwind_longjmp(buf, val) __libc_longjmp (buf, val)
diff --git a/sysdeps/riscv/ldsodefs.h b/sysdeps/riscv/ldsodefs.h
new file mode 100644
index 0000000..8820a08
--- /dev/null
+++ b/sysdeps/riscv/ldsodefs.h
@@ -0,0 +1,70 @@
+/* Run-time dynamic linker data structures for loaded ELF shared objects.
+   Copyright (C) 2000, 2002, 2003, 2006, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _MIPS_LDSODEFS_H
+#define _MIPS_LDSODEFS_H 1
+
+#include <elf.h>
+
+struct La_mips_32_regs;
+struct La_mips_32_retval;
+struct La_mips_64_regs;
+struct La_mips_64_retval;
+
+#define ARCH_PLTENTER_MEMBERS						    \
+    Elf32_Addr (*mips_o32_gnu_pltenter) (Elf32_Sym *, unsigned int,	    \
+					 uintptr_t *, uintptr_t *,	    \
+					 const struct La_mips_32_regs *,    \
+					 unsigned int *, const char *name,  \
+					 long int *framesizep);		    \
+    Elf32_Addr (*mips_n32_gnu_pltenter) (Elf32_Sym *, unsigned int,	    \
+					 uintptr_t *, uintptr_t *,	    \
+					 const struct La_mips_64_regs *,    \
+					 unsigned int *, const char *name,  \
+					 long int *framesizep);		    \
+    Elf64_Addr (*mips_n64_gnu_pltenter) (Elf64_Sym *, unsigned int,	    \
+					 uintptr_t *, uintptr_t *,	    \
+					 const struct La_mips_64_regs *,    \
+					 unsigned int *, const char *name,  \
+					 long int *framesizep);
+
+#define ARCH_PLTEXIT_MEMBERS						    \
+    unsigned int (*mips_o32_gnu_pltexit) (Elf32_Sym *, unsigned int,	    \
+					  uintptr_t *, uintptr_t *,	    \
+					  const struct La_mips_32_regs *,   \
+					  struct La_mips_32_retval *,	    \
+					  const char *);		    \
+    unsigned int (*mips_n32_gnu_pltexit) (Elf32_Sym *, unsigned int,	    \
+					  uintptr_t *, uintptr_t *,	    \
+					  const struct La_mips_64_regs *,   \
+					  struct La_mips_64_retval *,	    \
+					  const char *);		    \
+    unsigned int (*mips_n64_gnu_pltexit) (Elf64_Sym *, unsigned int,	    \
+					  uintptr_t *, uintptr_t *,	    \
+					  const struct La_mips_64_regs *,   \
+					  struct La_mips_64_retval *,	    \
+					  const char *);
+
+/* The MIPS ABI specifies that the dynamic section has to be read-only.  */
+
+#define DL_RO_DYN_SECTION 1
+
+#include_next <ldsodefs.h>
+
+#endif
diff --git a/sysdeps/riscv/libc-tls.c b/sysdeps/riscv/libc-tls.c
new file mode 100644
index 0000000..a3d6301
--- /dev/null
+++ b/sysdeps/riscv/libc-tls.c
@@ -0,0 +1,37 @@
+/* Thread-local storage handling in the ELF dynamic linker.  MIPS version.
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <csu/libc-tls.c>
+#include <dl-tls.h>
+
+#if USE_TLS
+
+/* On MIPS, linker optimizations are not required, so __tls_get_addr
+   can be called even in statically linked binaries.  In this case module
+   must be always 1 and PT_TLS segment exist in the binary, otherwise it
+   would not link.  */
+
+void *
+__tls_get_addr (tls_index *ti)
+{
+  dtv_t *dtv = THREAD_DTV ();
+  return (char *) dtv[1].pointer.val + GET_ADDR_OFFSET;
+}
+
+#endif
diff --git a/sysdeps/riscv/memcpy.c b/sysdeps/riscv/memcpy.c
new file mode 100644
index 0000000..3706ba6
--- /dev/null
+++ b/sysdeps/riscv/memcpy.c
@@ -0,0 +1,65 @@
+#include <string.h>
+#include <stdint.h>
+
+#undef memcpy
+#undef __memcpy_g
+
+void* __memcpy_g(void* aa, const void* bb, size_t n)
+{
+  #define BODY(a, b, t) { \
+    t tt = *b; \
+    a++, b++; \
+    *(a-1) = tt; \
+  }
+
+  char* a = (char*)aa;
+  const char* b = (const char*)bb;
+  char* end = a+n;
+  uintptr_t msk = sizeof(long)-1;
+  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
+  {
+foo:
+    if (__builtin_expect(a < end, 1))
+      while (a < end)
+        BODY(a, b, char);
+    return aa;
+  }
+
+  if (__builtin_expect(((uintptr_t)a & msk) != 0, 0))
+    while ((uintptr_t)a & msk)
+      BODY(a, b, char);
+
+  long* __restrict__ la = (long*)a;
+  const long* __restrict__ lb = (const long*)b;
+  long* lend = (long*)((uintptr_t)end & ~msk);
+
+  if (__builtin_expect(la < lend-8, 0))
+  {
+    while (la < lend-8)
+    {
+      *la++ = *lb++;
+      *la++ = *lb++;
+      *la++ = *lb++;
+      *la++ = *lb++;
+      *la++ = *lb++;
+      *la++ = *lb++;
+      *la++ = *lb++;
+      *la++ = *lb++;
+      *la++ = *lb++;
+    }
+    if (la == lend)
+      goto bar;
+  }
+
+  do BODY(la, lb, long) while (la < lend);
+
+bar:
+  a = (char*)la;
+  b = (const char*)lb;
+  if (__builtin_expect(a < end, 0))
+    goto foo;
+  return aa;
+}
+libc_hidden_def (__memcpy_g)
+strong_alias (__memcpy_g, memcpy)
+libc_hidden_builtin_def (memcpy)
diff --git a/sysdeps/riscv/memset.c b/sysdeps/riscv/memset.c
new file mode 100644
index 0000000..cfde2fe
--- /dev/null
+++ b/sysdeps/riscv/memset.c
@@ -0,0 +1,43 @@
+typedef unsigned long size_t;
+//#include <string.h>
+
+void* memset(void* dst, int val, size_t n)
+{
+  void* dst0 = dst;
+  void* end = dst + n;
+  unsigned char v = val;
+
+  /* is dst word-aligned? */
+  if (((long)dst & (sizeof(long)-1)) == 0)
+  {
+    long lval = v;
+    lval |= lval << 8;
+    lval |= lval << 16;
+    #ifdef __riscv64
+    lval |= lval << 32;
+    #elif !defined(__riscv32)
+    # error
+    #endif
+
+    /* set 4 words at a time */
+    for ( ; dst <= end - 4*sizeof(long); dst += 4*sizeof(long))
+    {
+      *(long*)(dst+0*sizeof(long)) = lval;
+      *(long*)(dst+1*sizeof(long)) = lval;
+      *(long*)(dst+2*sizeof(long)) = lval;
+      *(long*)(dst+3*sizeof(long)) = lval;
+    }
+
+    /* set a word at a time */
+    for ( ; dst <= end - sizeof(long); dst += sizeof(long))
+      *(long*)dst = lval;
+  }
+
+  /* set a byte at a time */
+  for ( ; dst < end; dst++)
+    *(unsigned char*)dst = v;
+
+  return dst0;
+}
+
+weak_alias (memset, __GI_memset)
diff --git a/sysdeps/riscv/memusage.h b/sysdeps/riscv/memusage.h
new file mode 100644
index 0000000..c558a06
--- /dev/null
+++ b/sysdeps/riscv/memusage.h
@@ -0,0 +1,21 @@
+/* Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define GETSP() ({ register uintptr_t stack_ptr asm ("sp"); stack_ptr; })
+
+#include <sysdeps/generic/memusage.h>
diff --git a/sysdeps/riscv/nptl/Makefile b/sysdeps/riscv/nptl/Makefile
new file mode 100644
index 0000000..d0c59a5
--- /dev/null
+++ b/sysdeps/riscv/nptl/Makefile
@@ -0,0 +1,25 @@
+# Copyright (C) 2005 Free Software Foundation, Inc.
+# This file is part of the GNU C Library.
+#
+# The GNU C Library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+#
+# The GNU C Library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public
+# License along with the GNU C Library; if not, write to the Free
+# Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+# 02111-1307 USA.
+
+ifeq ($(subdir),csu)
+gen-as-const-headers += tcb-offsets.sym
+endif
+
+ifeq ($(subdir),nptl)
+libpthread-sysdep_routines += nptl-sysdep
+endif
diff --git a/sysdeps/riscv/nptl/bits/pthreadtypes.h b/sysdeps/riscv/nptl/bits/pthreadtypes.h
new file mode 100644
index 0000000..ed8d1aa
--- /dev/null
+++ b/sysdeps/riscv/nptl/bits/pthreadtypes.h
@@ -0,0 +1,241 @@
+/* Machine-specific pthread type layouts.  RISC-V version.
+   Copyright (C) 2011-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_PTHREADTYPES_H
+#define _BITS_PTHREADTYPES_H	1
+
+#include <endian.h>
+
+#if _RISCV_SIM == _ABI64
+# define __SIZEOF_PTHREAD_ATTR_T 56
+# define __SIZEOF_PTHREAD_MUTEX_T 40
+# define __SIZEOF_PTHREAD_MUTEXATTR_T 4
+# define __SIZEOF_PTHREAD_COND_T 48
+# define __SIZEOF_PTHREAD_CONDATTR_T 4
+# define __SIZEOF_PTHREAD_RWLOCK_T 56
+# define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
+# define __SIZEOF_PTHREAD_BARRIER_T 32
+# define __SIZEOF_PTHREAD_BARRIERATTR_T 4
+#else
+# define __SIZEOF_PTHREAD_ATTR_T 36
+# define __SIZEOF_PTHREAD_MUTEX_T 24
+# define __SIZEOF_PTHREAD_MUTEXATTR_T 4
+# define __SIZEOF_PTHREAD_COND_T 48
+# define __SIZEOF_PTHREAD_CONDATTR_T 4
+# define __SIZEOF_PTHREAD_RWLOCK_T 32
+# define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
+# define __SIZEOF_PTHREAD_BARRIER_T 20
+# define __SIZEOF_PTHREAD_BARRIERATTR_T 4
+#endif
+
+
+/* Thread identifiers.  The structure of the attribute type is
+   deliberately not exposed.  */
+typedef unsigned long int pthread_t;
+
+
+union pthread_attr_t
+{
+  char __size[__SIZEOF_PTHREAD_ATTR_T];
+  long int __align;
+};
+#ifndef __have_pthread_attr_t
+typedef union pthread_attr_t pthread_attr_t;
+# define __have_pthread_attr_t  1
+#endif
+
+#if _RISCV_SIM == _ABI64
+typedef struct __pthread_internal_list
+{
+  struct __pthread_internal_list *__prev;
+  struct __pthread_internal_list *__next;
+} __pthread_list_t;
+#else
+typedef struct __pthread_internal_slist
+{
+  struct __pthread_internal_slist *__next;
+} __pthread_slist_t;
+#endif
+
+
+/* Data structures for mutex handling.  The structure of the attribute
+   type is deliberately not exposed.  */
+typedef union
+{
+  struct __pthread_mutex_s
+  {
+    int __lock;
+    unsigned int __count;
+    int __owner;
+#if _RISCV_SIM == _ABI64
+    unsigned int __nusers;
+#endif
+    /* KIND must stay at this position in the structure to maintain
+       binary compatibility.  */
+    int __kind;
+#if _RISCV_SIM == _ABI64
+    int __spins;
+    __pthread_list_t __list;
+# define __PTHREAD_MUTEX_HAVE_PREV	1
+#else
+    unsigned int __nusers;
+    __extension__ union
+    {
+      int __spins;
+      __pthread_slist_t __list;
+    };
+#endif
+  } __data;
+  char __size[__SIZEOF_PTHREAD_MUTEX_T];
+  long int __align;
+} pthread_mutex_t;
+
+/* Mutex __spins initializer used by PTHREAD_MUTEX_INITIALIZER.  */
+#define __PTHREAD_SPINS 0
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_MUTEXATTR_T];
+  int __align;
+} pthread_mutexattr_t;
+
+
+/* Data structure for conditional variable handling.  The structure of
+   the attribute type is deliberately not exposed.  */
+typedef union
+{
+  struct
+  {
+    int __lock;
+    unsigned int __futex;
+    __extension__ unsigned long long int __total_seq;
+    __extension__ unsigned long long int __wakeup_seq;
+    __extension__ unsigned long long int __woken_seq;
+    void *__mutex;
+    unsigned int __nwaiters;
+    unsigned int __broadcast_seq;
+  } __data;
+  char __size[__SIZEOF_PTHREAD_COND_T];
+  __extension__ long long int __align;
+} pthread_cond_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_CONDATTR_T];
+  int __align;
+} pthread_condattr_t;
+
+
+/* Keys for thread-specific data */
+typedef unsigned int pthread_key_t;
+
+
+/* Once-only execution */
+typedef int pthread_once_t;
+
+
+#if defined __USE_UNIX98 || defined __USE_XOPEN2K
+/* Data structure for read-write lock variable handling.  The
+   structure of the attribute type is deliberately not exposed.  */
+typedef union
+{
+# if _RISCV_SIM == _ABI64
+  struct
+  {
+    int __lock;
+    unsigned int __nr_readers;
+    unsigned int __readers_wakeup;
+    unsigned int __writer_wakeup;
+    unsigned int __nr_readers_queued;
+    unsigned int __nr_writers_queued;
+    int __writer;
+    int __shared;
+    unsigned long int __pad1;
+    unsigned long int __pad2;
+    /* FLAGS must stay at this position in the structure to maintain
+       binary compatibility.  */
+    unsigned int __flags;
+  } __data;
+# else
+  struct
+  {
+    int __lock;
+    unsigned int __nr_readers;
+    unsigned int __readers_wakeup;
+    unsigned int __writer_wakeup;
+    unsigned int __nr_readers_queued;
+    unsigned int __nr_writers_queued;
+#if __BYTE_ORDER == __BIG_ENDIAN
+    unsigned char __pad1;
+    unsigned char __pad2;
+    unsigned char __shared;
+    /* FLAGS must stay at this position in the structure to maintain
+       binary compatibility.  */
+    unsigned char __flags;
+#else
+    /* FLAGS must stay at this position in the structure to maintain
+       binary compatibility.  */
+    unsigned char __flags;
+    unsigned char __shared;
+    unsigned char __pad1;
+    unsigned char __pad2;
+#endif
+    int __writer;
+  } __data;
+# endif
+  char __size[__SIZEOF_PTHREAD_RWLOCK_T];
+  long int __align;
+} pthread_rwlock_t;
+
+#define __PTHREAD_RWLOCK_ELISION_EXTRA 0
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_RWLOCKATTR_T];
+  long int __align;
+} pthread_rwlockattr_t;
+#endif
+
+
+#ifdef __USE_XOPEN2K
+/* POSIX spinlock data type.  */
+#ifdef __riscv_atomic
+typedef volatile int pthread_spinlock_t;
+#else
+typedef pthread_mutex_t pthread_spinlock_t;
+#endif
+
+
+/* POSIX barriers data type.  The structure of the type is
+   deliberately not exposed.  */
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_BARRIER_T];
+  long int __align;
+} pthread_barrier_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_BARRIERATTR_T];
+  int __align;
+} pthread_barrierattr_t;
+#endif
+
+
+#endif	/* bits/pthreadtypes.h */
diff --git a/sysdeps/riscv/nptl/bits/semaphore.h b/sysdeps/riscv/nptl/bits/semaphore.h
new file mode 100644
index 0000000..28f8595
--- /dev/null
+++ b/sysdeps/riscv/nptl/bits/semaphore.h
@@ -0,0 +1,37 @@
+/* Copyright (C) 2002, 2005, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SEMAPHORE_H
+# error "Never use <bits/semaphore.h> directly; include <semaphore.h> instead."
+#endif
+
+#if _RISCV_SIM == _ABI64
+# define __SIZEOF_SEM_T	32
+#else
+# define __SIZEOF_SEM_T	16
+#endif
+
+/* Value returned if `sem_open' failed.  */
+#define SEM_FAILED      ((sem_t *) 0)
+
+
+typedef union
+{
+  char __size[__SIZEOF_SEM_T];
+  long int __align;
+} sem_t;
diff --git a/sysdeps/riscv/nptl/clone.S b/sysdeps/riscv/nptl/clone.S
new file mode 100644
index 0000000..4106a34
--- /dev/null
+++ b/sysdeps/riscv/nptl/clone.S
@@ -0,0 +1,2 @@
+#define RESET_PID
+#include <sysdeps/unix/sysv/linux/riscv/clone.S>
diff --git a/sysdeps/riscv/nptl/lowlevellock.h b/sysdeps/riscv/nptl/lowlevellock.h
new file mode 100644
index 0000000..834bc2a
--- /dev/null
+++ b/sysdeps/riscv/nptl/lowlevellock.h
@@ -0,0 +1,262 @@
+/* Copyright (C) 2011-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _LOWLEVELLOCK_H
+#define _LOWLEVELLOCK_H	1
+
+#include <time.h>
+#include <sys/param.h>
+#include <bits/pthreadtypes.h>
+#include <atomic.h>
+#include <sysdep.h>
+#include <kernel-features.h>
+
+#define FUTEX_WAIT		0
+#define FUTEX_WAKE		1
+#define FUTEX_REQUEUE		3
+#define FUTEX_CMP_REQUEUE	4
+#define FUTEX_WAKE_OP		5
+#define FUTEX_OP_CLEAR_WAKE_IF_GT_ONE	((4 << 24) | 1)
+#define FUTEX_LOCK_PI		6
+#define FUTEX_UNLOCK_PI		7
+#define FUTEX_TRYLOCK_PI	8
+#define FUTEX_WAIT_BITSET	9
+#define FUTEX_WAKE_BITSET	10
+#define FUTEX_PRIVATE_FLAG	128
+#define FUTEX_CLOCK_REALTIME	256
+
+#define FUTEX_BITSET_MATCH_ANY	0xffffffff
+
+/* Values for 'private' parameter of locking macros.  Yes, the
+   definition seems to be backwards.  But it is not.  The bit will be
+   reversed before passing to the system call.  */
+#define LLL_PRIVATE	0
+#define LLL_SHARED	FUTEX_PRIVATE_FLAG
+
+
+#if !defined NOT_IN_libc || defined IS_IN_rtld
+/* In libc.so or ld.so all futexes are private.  */
+# ifdef __ASSUME_PRIVATE_FUTEX
+#  define __lll_private_flag(fl, private) \
+  ((fl) | FUTEX_PRIVATE_FLAG)
+# else
+#  define __lll_private_flag(fl, private) \
+  ((fl) | THREAD_GETMEM (THREAD_SELF, header.private_futex))
+# endif
+#else
+# ifdef __ASSUME_PRIVATE_FUTEX
+#  define __lll_private_flag(fl, private) \
+  (((fl) | FUTEX_PRIVATE_FLAG) ^ (private))
+# else
+#  define __lll_private_flag(fl, private) \
+  (__builtin_constant_p (private)					      \
+   ? ((private) == 0							      \
+      ? ((fl) | THREAD_GETMEM (THREAD_SELF, header.private_futex))	      \
+      : (fl))								      \
+   : ((fl) | (((private) ^ FUTEX_PRIVATE_FLAG)				      \
+	      & THREAD_GETMEM (THREAD_SELF, header.private_futex))))
+# endif	      
+#endif
+
+
+#define lll_futex_wait(futexp, val, private) \
+  lll_futex_timed_wait(futexp, val, NULL, private)
+
+#define lll_futex_timed_wait(futexp, val, timespec, private) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 4, (long) (futexp),		      \
+			      __lll_private_flag (FUTEX_WAIT, private),	      \
+			      (val), (timespec));			      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err) ? -__ret : __ret;		      \
+  })
+
+#define lll_futex_wake(futexp, nr, private) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 4, (long) (futexp),		      \
+			      __lll_private_flag (FUTEX_WAKE, private),	      \
+			      (nr), 0);	      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err) ? -__ret : __ret;		      \
+  })
+
+#define lll_robust_dead(futexv, private) \
+  do									      \
+    {									      \
+      int *__futexp = &(futexv);					      \
+      atomic_or (__futexp, FUTEX_OWNER_DIED);				      \
+      lll_futex_wake (__futexp, 1, private);				      \
+    }									      \
+  while (0)
+
+/* Returns non-zero if error happened, zero if success.  */
+#define lll_futex_requeue(futexp, nr_wake, nr_move, mutex, val, private) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 6, (long) (futexp),		      \
+			      __lll_private_flag (FUTEX_CMP_REQUEUE, private),\
+			      (nr_wake), (nr_move), (mutex), (val));	      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err);				      \
+  })
+
+/* Returns non-zero if error happened, zero if success.  */
+#define lll_futex_wake_unlock(futexp, nr_wake, nr_wake2, futexp2, private) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+									      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 6, (futexp),		      \
+			      __lll_private_flag (FUTEX_WAKE_OP, private),    \
+			      (nr_wake), (nr_wake2), (futexp2),		      \
+			      FUTEX_OP_CLEAR_WAKE_IF_GT_ONE);		      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err);				      \
+  })
+
+#define lll_trylock(futex) \
+  ({                                                                          \
+    atomic_compare_and_exchange_val_acq (&(futex), 1, 0) != 0;                \
+  })
+
+#define lll_cond_trylock(futex) \
+  ({                                                                          \
+    atomic_compare_and_exchange_val_acq (&(futex), 2, 0) != 0;                \
+  })
+
+#define lll_robust_trylock(futex, id) \
+  ({                                                                          \
+    atomic_compare_and_exchange_val_acq (&(futex), id, 0) != 0;               \
+  })
+
+extern void __lll_lock_wait_private (int *futex) attribute_hidden;
+extern void __lll_lock_wait (int *futex, int private) attribute_hidden;
+extern int __lll_robust_lock_wait (int *futex, int private) attribute_hidden;
+
+#define lll_lock(futex, private) \
+  ({                                                                          \
+    int val = atomic_compare_and_exchange_val_acq (&(futex), 1, 0);           \
+                                                                              \
+    if (__builtin_expect (val != 0, 0))                                       \
+      {                                                                       \
+        if (__builtin_constant_p (private) && private == LLL_PRIVATE)         \
+          __lll_lock_wait_private (&(futex));                                 \
+        else                                                                  \
+          __lll_lock_wait (&(futex), private);                                \
+      }                                                                       \
+  })
+
+#define lll_robust_lock(futex, id, private) \
+  ({                                                                          \
+    int result = 0;                                                           \
+    if (atomic_compare_and_exchange_bool_acq (&(futex), id, 0) != 0)          \
+      result = __lll_robust_lock_wait (&(futex), private);                    \
+    result;                                                                   \
+  })
+
+#define lll_cond_lock(futex, private) \
+  ({                                                                          \
+    int val = atomic_compare_and_exchange_val_acq (&(futex), 2, 0);           \
+                                                                              \
+    if (__builtin_expect (val != 0, 0))                                       \
+      __lll_lock_wait (&(futex), private);                                    \
+  })
+
+#define lll_robust_cond_lock(futex, id, private) \
+  lll_robust_lock (futex, (id) | FUTEX_WAITERS, private)
+
+
+extern int __lll_timedlock_wait (int *futex, const struct timespec *,
+				 int private) attribute_hidden;
+extern int __lll_robust_timedlock_wait (int *futex, const struct timespec *,
+					int private) attribute_hidden;
+
+#define lll_timedlock(futex, abstime, private) \
+  ({                                                                          \
+    int val = atomic_compare_and_exchange_val_acq (&(futex), 1, 0);           \
+    int result = 0;                                                           \
+                                                                              \
+    if (__builtin_expect (val != 0, 0))                                       \
+      result = __lll_timedlock_wait (&(futex), abstime, private);             \
+    result;                                                                   \
+  })
+
+#define lll_robust_timedlock(futex, abstime, id, private) \
+  ({                                                                          \
+    int result = 0;                                                           \
+    if (atomic_compare_and_exchange_bool_acq (&(futex), id, 0) != 0)          \
+      result = __lll_robust_timedlock_wait (&(futex), abstime, private);      \
+    result;                                                                   \
+  })
+
+#define lll_unlock(lock, private) \
+  ((void) ({								      \
+    int *__futex = &(lock);						      \
+    int __val = atomic_exchange_rel (__futex, 0);			      \
+    if (__builtin_expect (__val > 1, 0))				      \
+      lll_futex_wake (__futex, 1, private);				      \
+  }))
+
+#define lll_robust_unlock(lock, private) \
+  ((void) ({								      \
+    int *__futex = &(lock);						      \
+    int __val = atomic_exchange_rel (__futex, 0);			      \
+    if (__builtin_expect (__val & FUTEX_WAITERS, 0))			      \
+      lll_futex_wake (__futex, 1, private);				      \
+  }))
+
+#define lll_islocked(futex) \
+  (futex != 0)
+
+
+/* Our internal lock implementation is identical to the binary-compatible
+   mutex implementation. */
+
+/* Initializers for lock.  */
+#define LLL_LOCK_INITIALIZER		(0)
+#define LLL_LOCK_INITIALIZER_LOCKED	(1)
+
+/* The states of a lock are:
+    0  -  untaken
+    1  -  taken by one user
+   >1  -  taken by more users */
+
+/* The kernel notifies a process which uses CLONE_CLEARTID via futex
+   wakeup when the clone terminates.  The memory location contains the
+   thread ID while the clone is running and is reset to zero
+   afterwards.	*/
+#define lll_wait_tid(tid) \
+  do {							\
+    __typeof (tid) __tid;				\
+    while ((__tid = (tid)) != 0)			\
+      lll_futex_wait (&(tid), __tid, LLL_SHARED);	\
+  } while (0)
+
+extern int __lll_timedwait_tid (int *, const struct timespec *)
+     attribute_hidden;
+
+#define lll_timedwait_tid(tid, abstime) \
+  ({							\
+    int __res = 0;					\
+    if ((tid) != 0)					\
+      __res = __lll_timedwait_tid (&(tid), (abstime));	\
+    __res;						\
+  })
+
+#endif	/* lowlevellock.h */
diff --git a/sysdeps/riscv/nptl/nptl-sysdep.c b/sysdeps/riscv/nptl/nptl-sysdep.c
new file mode 100644
index 0000000..16c1736
--- /dev/null
+++ b/sysdeps/riscv/nptl/nptl-sysdep.c
@@ -0,0 +1,2 @@
+/* Pull in __syscall_error.  */
+#include <sysdep.c>
diff --git a/sysdeps/riscv/nptl/pt-vfork.S b/sysdeps/riscv/nptl/pt-vfork.S
new file mode 100644
index 0000000..1fdbb26
--- /dev/null
+++ b/sysdeps/riscv/nptl/pt-vfork.S
@@ -0,0 +1,36 @@
+/* Copyright (C) 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <tls.h>
+#include "tcb-offsets.h"
+
+/* Save the PID value.  */
+#define SAVE_PID \
+	lw	t0, PID_OFFSET(tp);	/* Load the saved PID.  */	\
+	neg	t0, t0;			/* Negate it.  */		\
+	sw	t0, PID_OFFSET(tp);	/* Store the temporary PID.  */
+
+/* Restore the old PID value in the parent.  */
+#define RESTORE_PID \
+	beqz	v0, 1f;			/* If we are the parent... */	\
+	lw	t0, PID_OFFSET(tp);	/* Load the saved PID.  */	\
+	neg	t0, t0;			/* Re-negate it.  */		\
+	sw	t0, PID_OFFSET(tp);	/* Restore the PID.  */		\
+1:
+
+#include <sysdeps/unix/sysv/linux/riscv/vfork.S>
diff --git a/sysdeps/riscv/nptl/pthread_spin_destroy.c b/sysdeps/riscv/nptl/pthread_spin_destroy.c
new file mode 100644
index 0000000..e1eed80
--- /dev/null
+++ b/sysdeps/riscv/nptl/pthread_spin_destroy.c
@@ -0,0 +1,30 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include "pthreadP.h"
+
+
+#ifndef __riscv_atomic
+int
+pthread_spin_destroy (lock)
+     pthread_spinlock_t *lock;
+{
+  return pthread_mutex_destroy(lock);
+}
+#endif
diff --git a/sysdeps/riscv/nptl/pthread_spin_init.c b/sysdeps/riscv/nptl/pthread_spin_init.c
new file mode 100644
index 0000000..b85181a
--- /dev/null
+++ b/sysdeps/riscv/nptl/pthread_spin_init.c
@@ -0,0 +1,30 @@
+/* pthread_spin_init -- initialize a spin lock.  Generic version.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Paul Mackerras <paulus@au.ibm.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include "pthreadP.h"
+
+
+#ifndef __riscv_atomic
+int
+pthread_spin_init (pthread_spinlock_t *lock, int pshared)
+{
+  return pthread_mutex_init(lock, NULL);
+}
+#endif
diff --git a/sysdeps/riscv/nptl/pthread_spin_lock.c b/sysdeps/riscv/nptl/pthread_spin_lock.c
new file mode 100644
index 0000000..0e8840b
--- /dev/null
+++ b/sysdeps/riscv/nptl/pthread_spin_lock.c
@@ -0,0 +1,39 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+
+int pthread_spin_lock(pthread_spinlock_t* lock)
+{
+#ifdef __riscv_atomic
+  int tmp1, tmp2;
+
+  asm volatile ("\n\
+  1:lw           %0, 0(%2)\n\
+    li           %1, %3\n\
+    bnez         %0, 1b\n\
+    amoswap.w.aq %0, %1, 0(%2)\n\
+    bnez         %0, 1b"
+    : "=&r"(tmp1), "=&r"(tmp2) : "r"(lock), "i"(EBUSY)
+  );
+
+  return tmp1;
+#else
+  return pthread_mutex_lock(lock);
+#endif
+}
diff --git a/sysdeps/riscv/nptl/pthread_spin_trylock.c b/sysdeps/riscv/nptl/pthread_spin_trylock.c
new file mode 100644
index 0000000..b19ec5e
--- /dev/null
+++ b/sysdeps/riscv/nptl/pthread_spin_trylock.c
@@ -0,0 +1,39 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+
+int pthread_spin_trylock(pthread_spinlock_t* lock)
+{
+#ifdef __riscv_atomic
+  int tmp1, tmp2;
+
+  asm volatile ("\n\
+    lw           %0, 0(%2)\n\
+    li           %1, %3\n\
+    bnez         %0, 1f\n\
+    amoswap.w.aq %0, %1, 0(%2)\n\
+  1:"
+    : "=&r"(tmp1), "=&r"(tmp2) : "r"(lock), "i"(EBUSY)
+  );
+
+  return tmp1;
+#else
+  return pthread_mutex_trylock(lock);
+#endif
+}
diff --git a/sysdeps/riscv/nptl/pthread_spin_unlock.c b/sysdeps/riscv/nptl/pthread_spin_unlock.c
new file mode 100644
index 0000000..133311c
--- /dev/null
+++ b/sysdeps/riscv/nptl/pthread_spin_unlock.c
@@ -0,0 +1,33 @@
+/* pthread_spin_unlock -- unlock a spin lock.  Generic version.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Paul Mackerras <paulus@au.ibm.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include "pthreadP.h"
+#include <atomic.h>
+
+int
+pthread_spin_unlock (pthread_spinlock_t *lock)
+{
+#ifdef __riscv_atomic
+  asm volatile ("amoswap.w.rl x0, x0, 0(%0)" : : "r"(lock));
+  return 0;
+#else
+  return pthread_mutex_unlock(lock);
+#endif
+}
diff --git a/sysdeps/riscv/nptl/pthreaddef.h b/sysdeps/riscv/nptl/pthreaddef.h
new file mode 100644
index 0000000..59927ed
--- /dev/null
+++ b/sysdeps/riscv/nptl/pthreaddef.h
@@ -0,0 +1,32 @@
+/* Copyright (C) 2011-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Default stack size.  */
+#define ARCH_STACK_DEFAULT_SIZE	(2 * 1024 * 1024)
+
+/* Required stack pointer alignment at beginning.  */
+#define STACK_ALIGN		16
+
+/* Minimal stack size after allocating thread descriptor and guard size.  */
+#define MINIMAL_REST_STACK	2048
+
+/* Alignment requirement for TCB.  */
+#define TCB_ALIGNMENT		16
+
+/* Location of current stack frame.  */
+#define CURRENT_STACK_FRAME	__builtin_frame_address (0)
diff --git a/sysdeps/riscv/nptl/sysdep-cancel.h b/sysdeps/riscv/nptl/sysdep-cancel.h
new file mode 100644
index 0000000..3c1a396
--- /dev/null
+++ b/sysdeps/riscv/nptl/sysdep-cancel.h
@@ -0,0 +1,143 @@
+/* Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <sysdeps/generic/sysdep.h>
+#include <tls.h>
+#ifndef __ASSEMBLER__
+# include <nptl/pthreadP.h>
+#endif
+#include <sys/asm.h>
+
+/* Gas will put the initial save of $gp into the CIE, because it appears to
+   happen before any instructions.  So we use cfi_same_value instead of
+   cfi_restore.  */
+
+#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
+
+# undef PSEUDO
+# define PSEUDO(name, syscall_name, args)				\
+      .align 2;								\
+  L(pseudo_start):							\
+      cfi_startproc;							\
+  99: j __syscall_error;						\
+  ENTRY (name)								\
+    SINGLE_THREAD_P(v1);						\
+    bnez v1, L(pseudo_cancel);  					\
+  .type __##syscall_name##_nocancel, @function;				\
+  .globl __##syscall_name##_nocancel;					\
+  __##syscall_name##_nocancel:						\
+    li v0, SYS_ify(syscall_name);					\
+    scall;								\
+    bltz v0, 99b;							\
+    ret;								\
+  .size __##syscall_name##_nocancel,.-__##syscall_name##_nocancel;	\
+  L(pseudo_cancel):							\
+    SAVESTK;								\
+    REG_S ra, STKOFF_RA(sp);						\
+    cfi_rel_offset (ra, STKOFF_RA);					\
+      PUSHARGS_##args;			/* save syscall args */		\
+      CENABLE;								\
+      POPARGS_##args;			/* restore syscall args */	\
+      REG_S v0, STKOFF_SVMSK(sp);	/* save mask */			\
+      li v0, SYS_ify (syscall_name);					\
+      scall;								\
+      REG_S v0, STKOFF_SC_V0(sp);	/* save syscall result */	\
+      REG_L a0, STKOFF_SVMSK(sp);	/* pass mask as arg1 */		\
+      CDISABLE;								\
+      REG_L v0, STKOFF_SC_V0(sp);	/* restore syscall result */	\
+      REG_L ra, STKOFF_RA(sp);		/* restore return address */	\
+      RESTORESTK;							\
+      bltz v0, 99b;							\
+    L(pseudo_end):
+
+
+# undef PSEUDO_END
+# define PSEUDO_END(sym) cfi_endproc; .size sym,.-sym
+
+# define PUSHARGS_0	/* nothing to do */
+# define PUSHARGS_1	PUSHARGS_0 REG_S a0, STKOFF_A0(sp); cfi_rel_offset (a0, STKOFF_A0);
+# define PUSHARGS_2	PUSHARGS_1 REG_S a1, STKOFF_A1(sp); cfi_rel_offset (a1, STKOFF_A1);
+# define PUSHARGS_3	PUSHARGS_2 REG_S a2, STKOFF_A2(sp); cfi_rel_offset (a2, STKOFF_A2);
+# define PUSHARGS_4	PUSHARGS_3 REG_S a3, STKOFF_A3(sp); cfi_rel_offset (a3, STKOFF_A3);
+# define PUSHARGS_5	PUSHARGS_4 REG_S a4, STKOFF_A4(sp); cfi_rel_offset (a3, STKOFF_A4);
+# define PUSHARGS_6	PUSHARGS_5 REG_S a5, STKOFF_A5(sp); cfi_rel_offset (a3, STKOFF_A5);
+
+# define POPARGS_0	/* nothing to do */
+# define POPARGS_1	POPARGS_0 REG_L a0, STKOFF_A0(sp);
+# define POPARGS_2	POPARGS_1 REG_L a1, STKOFF_A1(sp);
+# define POPARGS_3	POPARGS_2 REG_L a2, STKOFF_A2(sp);
+# define POPARGS_4	POPARGS_3 REG_L a3, STKOFF_A3(sp);
+# define POPARGS_5	POPARGS_4 REG_L a4, STKOFF_A4(sp);
+# define POPARGS_6	POPARGS_5 REG_L a5, STKOFF_A5(sp);
+
+/* Save an even number of slots.  Should be 0 if an even number of slots
+   are used below, or SZREG if an odd number are used.  */
+# define STK_PAD	0
+
+/* Place values that we are more likely to use later in this sequence, i.e.
+   closer to the SP at function entry.  If you do that, the are more
+   likely to already be in your d-cache.  */
+# define STKOFF_A5	(STK_PAD)
+# define STKOFF_A4	(STKOFF_A5 + SZREG)
+# define STKOFF_A3	(STKOFF_A4 + SZREG)
+# define STKOFF_A2	(STKOFF_A3 + SZREG)	/* MT and more args.  */
+# define STKOFF_A1	(STKOFF_A2 + SZREG)	/* MT and 2 args.  */
+# define STKOFF_SVMSK	STKOFF_A1		/* Used if MT.  */
+# define STKOFF_A0	(STKOFF_A1 + SZREG)	/* MT and 1 arg.  */
+# define STKOFF_SC_V0	STKOFF_A0		/* Used if MT.  */
+# define STKOFF_RA	(STKOFF_A0 + SZREG)	/* Used if MT.  */
+
+# define STKSPACE	(STKOFF_RA + SZREG)
+# define SAVESTK 	addi sp, sp, -STKSPACE; cfi_adjust_cfa_offset(STKSPACE)
+# define RESTORESTK 	addi sp, sp, STKSPACE; cfi_adjust_cfa_offset(-STKSPACE)
+
+# ifdef IS_IN_libpthread
+#  define CENABLE  jal __pthread_enable_asynccancel
+#  define CDISABLE jal __pthread_disable_asynccancel
+# elif defined IS_IN_librt
+#  define CENABLE  jal __librt_enable_asynccancel
+#  define CDISABLE jal __librt_disable_asynccancel
+# else
+#  define CENABLE  jal __libc_enable_asynccancel
+#  define CDISABLE jal __libc_disable_asynccancel
+# endif
+
+# ifndef __ASSEMBLER__
+#  define SINGLE_THREAD_P						\
+	__builtin_expect (THREAD_GETMEM (THREAD_SELF,			\
+					 header.multiple_threads)	\
+			  == 0, 1)
+# else
+#  include "tcb-offsets.h"
+#  define SINGLE_THREAD_P(reg)						\
+	lw reg, MULTIPLE_THREADS_OFFSET(tp)
+#endif
+
+#elif !defined __ASSEMBLER__
+
+# define SINGLE_THREAD_P 1
+# define NO_CANCELLATION 1
+
+#endif
+
+#ifndef __ASSEMBLER__
+# define RTLD_SINGLE_THREAD_P \
+  __builtin_expect (THREAD_GETMEM (THREAD_SELF, \
+				   header.multiple_threads) == 0, 1)
+#endif
diff --git a/sysdeps/riscv/nptl/tcb-offsets.sym b/sysdeps/riscv/nptl/tcb-offsets.sym
new file mode 100644
index 0000000..e0e71dc
--- /dev/null
+++ b/sysdeps/riscv/nptl/tcb-offsets.sym
@@ -0,0 +1,11 @@
+#include <sysdep.h>
+#include <tls.h>
+
+--
+
+-- Abuse tls.h macros to derive offsets relative to the thread register.
+#define thread_offsetof(mem)	(long)(offsetof(struct pthread, mem) - TLS_TCB_OFFSET - TLS_PRE_TCB_SIZE)
+
+MULTIPLE_THREADS_OFFSET		thread_offsetof (header.multiple_threads)
+PID_OFFSET			thread_offsetof (pid)
+TID_OFFSET			thread_offsetof (tid)
diff --git a/sysdeps/riscv/nptl/tls.h b/sysdeps/riscv/nptl/tls.h
new file mode 100644
index 0000000..2982f97
--- /dev/null
+++ b/sysdeps/riscv/nptl/tls.h
@@ -0,0 +1,159 @@
+/* Definition for thread-local data handling.  NPTL/RISC-V version.
+   Copyright (C) 2011-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _RISCV_TLS_H
+#define _RISCV_TLS_H	1
+
+#include <dl-sysdep.h>
+
+/* Signal that TLS support is available.  */
+#define USE_TLS	1
+
+#ifndef __ASSEMBLER__
+# include <stdbool.h>
+# include <stddef.h>
+# include <stdint.h>
+
+/* Type for the dtv.  */
+typedef union dtv
+{
+  size_t counter;
+  struct
+  {
+    void *val;
+    bool is_static;
+  } pointer;
+} dtv_t;
+
+register void* __thread_self asm("tp");
+# define READ_THREAD_POINTER() ({ __thread_self; })
+
+/* Get system call information.  */
+# include <sysdep.h>
+
+/* The TP points to the start of the thread blocks.  */
+# define TLS_DTV_AT_TP	1
+# define TLS_TCB_AT_TP	0
+
+/* Get the thread descriptor definition.  */
+# include <nptl/descr.h>
+
+typedef struct
+{
+  dtv_t *dtv;
+  void *private;
+} tcbhead_t;
+
+/* This is the size of the initial TCB.  Because our TCB is before the thread
+   pointer, we don't need this.  */
+# define TLS_INIT_TCB_SIZE	0
+
+/* Alignment requirements for the initial TCB.  */
+# define TLS_INIT_TCB_ALIGN	__alignof__ (struct pthread)
+
+/* This is the size of the TCB.  Because our TCB is before the thread
+   pointer, we don't need this.  */
+# define TLS_TCB_SIZE		0
+
+/* Alignment requirements for the TCB.  */
+# define TLS_TCB_ALIGN		__alignof__ (struct pthread)
+
+/* This is the size we need before TCB - actually, it includes the TCB.  */
+# define TLS_PRE_TCB_SIZE \
+  (sizeof (struct pthread)						      \
+   + ((sizeof (tcbhead_t) + TLS_TCB_ALIGN - 1) & ~(TLS_TCB_ALIGN - 1)))
+
+/* The thread pointer tp points to the end of the TCB.
+   The pthread_descr structure is immediately in front of the TCB. */
+# define TLS_TCB_OFFSET	0
+
+/* Install the dtv pointer.  The pointer passed is to the element with
+   index -1 which contain the length.  */
+# define INSTALL_DTV(tcbp, dtvp) \
+  (((tcbhead_t *) (tcbp))[-1].dtv = (dtvp) + 1)
+
+/* Install new dtv for current thread.  */
+# define INSTALL_NEW_DTV(dtv) \
+  (THREAD_DTV() = (dtv))
+
+/* Return dtv of given thread descriptor.  */
+# define GET_DTV(tcbp) \
+  (((tcbhead_t *) (tcbp))[-1].dtv)
+
+/* Code to initially initialize the thread pointer. */
+# define TLS_INIT_TP(tcbp) \
+  ({ __thread_self = (char*)tcbp + TLS_TCB_OFFSET; NULL; })
+
+/* Return the address of the dtv for the current thread.  */
+# define THREAD_DTV() \
+  (((tcbhead_t *) (READ_THREAD_POINTER () - TLS_TCB_OFFSET))[-1].dtv)
+
+/* Return the thread descriptor for the current thread.  */
+# define THREAD_SELF \
+ ((struct pthread *) (READ_THREAD_POINTER ()			     \
+		      - TLS_TCB_OFFSET - TLS_PRE_TCB_SIZE))
+
+/* Value passed to 'clone' for initialization of the thread register.  */
+# define TLS_DEFINE_INIT_TP(tp, pd) \
+  void *tp = (void *) (pd) + TLS_TCB_OFFSET + TLS_PRE_TCB_SIZE
+
+/* Magic for libthread_db to know how to do THREAD_SELF.  */
+# define DB_THREAD_SELF \
+  CONST_THREAD_AREA (32, TLS_TCB_OFFSET + TLS_PRE_TCB_SIZE)
+
+/* Access to data in the thread descriptor is easy.  */
+# define THREAD_GETMEM(descr, member) \
+  descr->member
+# define THREAD_GETMEM_NC(descr, member, idx) \
+  descr->member[idx]
+# define THREAD_SETMEM(descr, member, value) \
+  descr->member = (value)
+# define THREAD_SETMEM_NC(descr, member, idx, value) \
+  descr->member[idx] = (value)
+
+/* l_tls_offset == 0 is perfectly valid, so we have to use some different
+   value to mean unset l_tls_offset.  */
+# define NO_TLS_OFFSET		-1
+
+/* Get and set the global scope generation counter in struct pthread.  */
+# define THREAD_GSCOPE_FLAG_UNUSED 0
+# define THREAD_GSCOPE_FLAG_USED   1
+# define THREAD_GSCOPE_FLAG_WAIT   2
+# define THREAD_GSCOPE_RESET_FLAG() \
+  do									     \
+    { int __res								     \
+	= atomic_exchange_rel (&THREAD_SELF->header.gscope_flag,	     \
+			       THREAD_GSCOPE_FLAG_UNUSED);		     \
+      if (__res == THREAD_GSCOPE_FLAG_WAIT)				     \
+	lll_futex_wake (&THREAD_SELF->header.gscope_flag, 1, LLL_PRIVATE);   \
+    }									     \
+  while (0)
+# define THREAD_GSCOPE_SET_FLAG() \
+  do									     \
+    {									     \
+      THREAD_SELF->header.gscope_flag = THREAD_GSCOPE_FLAG_USED;	     \
+      atomic_write_barrier ();						     \
+    }									     \
+  while (0)
+# define THREAD_GSCOPE_WAIT() \
+  GL(dl_wait_lookup_done) ()
+
+#endif /* __ASSEMBLER__ */
+
+#endif	/* tls.h */
diff --git a/sysdeps/riscv/nptl/vfork.S b/sysdeps/riscv/nptl/vfork.S
new file mode 100644
index 0000000..7fabe8a
--- /dev/null
+++ b/sysdeps/riscv/nptl/vfork.S
@@ -0,0 +1,41 @@
+/* Copyright (C) 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <tls.h>
+#include "tcb-offsets.h"
+
+/* Save the PID value.  */
+#define SAVE_PID \
+	lw	t0, PID_OFFSET(tp);		/* Load the saved PID.  */	\
+	neg	t0, t0;				/* Negate it.  */		\
+	bnez	t0, 1f;				/* If it was zero... */		\
+	li	t0, 0x80000000;			/* use 0x80000000 instead.  */	\
+1:	sw	t0, PID_OFFSET(tp);		/* Store the temporary PID.  */
+
+/* Restore the old PID value in the parent.  */
+#define RESTORE_PID \
+	beqz	v0, 1f;				/* If we are the parent... */	\
+	lw	t0, PID_OFFSET(tp);		/* Load the saved PID.  */	\
+	neg	t0, t0;			 	/* Re-negate it.  */		\
+	li	t1, 0x80000000;			/* Load 0x80000000... */	\
+	bne	t0, t1, 2f;			/* ... compare against it... */	\
+	li	t0, 0;				/* ... use 0 instead.  */	\
+2:	sw	t0, PID_OFFSET(tp);		/* Restore the PID.  */		\
+1:
+
+#include <sysdeps/unix/sysv/linux/riscv/vfork.S>
diff --git a/sysdeps/riscv/preconfigure b/sysdeps/riscv/preconfigure
new file mode 100644
index 0000000..2a5a109
--- /dev/null
+++ b/sysdeps/riscv/preconfigure
@@ -0,0 +1,21 @@
+case "$CC $CFLAGS $CPPFLAGS " in
+*" -m32 "*) riscv_cc_abi=32 ;;
+*" -m64 "*) riscv_cc_abi=64 ;;
+*) riscv_cc_abi=default ;;
+esac
+case $config_os in
+*64*) riscv_config_abi=64 ;;
+*32*) riscv_config_abi=32 ;;
+*) riscv_config_abi=$riscv_cc_abi ;;
+esac
+case $riscv_config_abi in
+default) base_machine=riscv machine=riscv/rv64 ;;
+32) base_machine=riscv machine=riscv/rv32 ;;
+64) base_machine=riscv machine=riscv/rv64 ;;
+esac
+machine=$machine/$config_machine
+if test $riscv_config_abi != $riscv_cc_abi; then
+  # This won't make it to config.make, but we want to
+  # set this in case configure tests depend on it.
+  CPPFLAGS="$CPPFLAGS -m$riscv_config_abi"
+fi
diff --git a/sysdeps/riscv/rv32/Implies b/sysdeps/riscv/rv32/Implies
new file mode 100644
index 0000000..b2313e9
--- /dev/null
+++ b/sysdeps/riscv/rv32/Implies
@@ -0,0 +1,2 @@
+riscv
+wordsize-32
diff --git a/sysdeps/riscv/rv32/Makefile b/sysdeps/riscv/rv32/Makefile
new file mode 100644
index 0000000..f9c69e3
--- /dev/null
+++ b/sysdeps/riscv/rv32/Makefile
@@ -0,0 +1,3 @@
+ifeq ($(filter -m32,$(CC)),)
+CC += -m32
+endif
diff --git a/sysdeps/riscv/rv64/Implies b/sysdeps/riscv/rv64/Implies
new file mode 100644
index 0000000..fae63bc
--- /dev/null
+++ b/sysdeps/riscv/rv64/Implies
@@ -0,0 +1,6 @@
+ieee754/flt-32
+ieee754/dbl-64
+riscv/rv64/soft-fp
+riscv/rv64
+riscv
+wordsize-64
diff --git a/sysdeps/riscv/rv64/Makefile b/sysdeps/riscv/rv64/Makefile
new file mode 100644
index 0000000..26b6a49
--- /dev/null
+++ b/sysdeps/riscv/rv64/Makefile
@@ -0,0 +1,6 @@
+# Link libc.so at its likely load address for faster dynamic linking
+LDLIBS-c.so += -Wl,--section-start=.dynamic=0x40100270
+
+ifeq ($(filter -m64,$(CC)),)
+CC += -m64
+endif
diff --git a/sysdeps/riscv/rv64/Versions b/sysdeps/riscv/rv64/Versions
new file mode 100644
index 0000000..253a65f
--- /dev/null
+++ b/sysdeps/riscv/rv64/Versions
@@ -0,0 +1,7 @@
+libm {
+  GLIBC_2.1 {
+    # A generic bug got this omitted from other configurations' version
+    # sets, but we always had it.
+    exp2l;
+  }
+}
diff --git a/sysdeps/riscv/rv64/gmp-mparam.h b/sysdeps/riscv/rv64/gmp-mparam.h
new file mode 100644
index 0000000..7666137
--- /dev/null
+++ b/sysdeps/riscv/rv64/gmp-mparam.h
@@ -0,0 +1,31 @@
+/* gmp-mparam.h -- Compiler/machine parameter header file.
+
+Copyright (C) 1991, 1993, 1994, 2002, 2003 Free Software Foundation, Inc.
+
+This file is part of the GNU MP Library.
+
+The GNU MP Library is free software; you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation; either version 2.1 of the License, or (at your
+option) any later version.
+
+The GNU MP Library is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with the GNU MP Library; see the file COPYING.LIB.  If not, write to
+the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */
+
+#if defined __GMP_H__ && ! defined _LONG_LONG_LIMB
+#error "Included too late for _LONG_LONG_LIMB to take effect"
+#endif
+
+#define _LONG_LONG_LIMB
+#define BITS_PER_MP_LIMB 64
+#define BYTES_PER_MP_LIMB 8
+#define BITS_PER_LONGINT __WORDSIZE
+#define BITS_PER_INT 32
+#define BITS_PER_SHORTINT 16
+#define BITS_PER_CHAR 8
diff --git a/sysdeps/riscv/rv64/soft-fp/Makefile b/sysdeps/riscv/rv64/soft-fp/Makefile
new file mode 100644
index 0000000..ada13e8
--- /dev/null
+++ b/sysdeps/riscv/rv64/soft-fp/Makefile
@@ -0,0 +1,3 @@
+ifeq ($(subdir),math)
+CPPFLAGS += -I../soft-fp
+endif
diff --git a/sysdeps/riscv/rv64/soft-fp/sfp-machine.h b/sysdeps/riscv/rv64/soft-fp/sfp-machine.h
new file mode 100644
index 0000000..0bf2776
--- /dev/null
+++ b/sysdeps/riscv/rv64/soft-fp/sfp-machine.h
@@ -0,0 +1,74 @@
+#include <fenv.h>
+#include <fpu_control.h>
+
+#define _FP_W_TYPE_SIZE		64
+#define _FP_W_TYPE		unsigned long long
+#define _FP_WS_TYPE		signed long long
+#define _FP_I_TYPE		long long
+
+#define _FP_MUL_MEAT_S(R,X,Y)					\
+  _FP_MUL_MEAT_1_imm(_FP_WFRACBITS_S,R,X,Y)
+#define _FP_MUL_MEAT_D(R,X,Y)					\
+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_Q(R,X,Y)					\
+  _FP_MUL_MEAT_2_wide_3mul(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)
+
+#define _FP_DIV_MEAT_S(R,X,Y)	_FP_DIV_MEAT_1_imm(S,R,X,Y,_FP_DIV_HELP_imm)
+#define _FP_DIV_MEAT_D(R,X,Y)	_FP_DIV_MEAT_1_udiv_norm(D,R,X,Y)
+#define _FP_DIV_MEAT_Q(R,X,Y)	_FP_DIV_MEAT_2_udiv(Q,R,X,Y)
+
+#define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
+#define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1)
+#define _FP_NANFRAC_Q		((_FP_QNANBIT_Q << 1) - 1), -1
+#define _FP_NANSIGN_S		0
+#define _FP_NANSIGN_D		0
+#define _FP_NANSIGN_Q		0
+
+#define _FP_KEEPNANFRACP 1
+/* From my experiments it seems X is chosen unless one of the
+   NaNs is sNaN,  in which case the result is NANSIGN/NANFRAC.  */
+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)			\
+  do {								\
+    if ((_FP_FRAC_HIGH_RAW_##fs(X) |				\
+	 _FP_FRAC_HIGH_RAW_##fs(Y)) & _FP_QNANBIT_##fs)		\
+      {								\
+	R##_s = _FP_NANSIGN_##fs;				\
+        _FP_FRAC_SET_##wc(R,_FP_NANFRAC_##fs);			\
+      }								\
+    else							\
+      {								\
+	R##_s = X##_s;						\
+        _FP_FRAC_COPY_##wc(R,X);				\
+      }								\
+    R##_c = FP_CLS_NAN;						\
+  } while (0)
+
+#define _FP_DECL_EX		fpu_control_t _fcw
+
+#define FP_ROUNDMODE		(_fcw >> 5)
+
+#define FP_RND_NEAREST		FE_TONEAREST
+#define FP_RND_ZERO		FE_TOWARDZERO
+#define FP_RND_PINF		FE_UPWARD
+#define FP_RND_MINF		FE_DOWNWARD
+
+#define FP_EX_INVALID		FE_INVALID
+#define FP_EX_OVERFLOW		FE_OVERFLOW
+#define FP_EX_UNDERFLOW		FE_UNDERFLOW
+#define FP_EX_DIVZERO		FE_DIVBYZERO
+#define FP_EX_INEXACT		FE_INEXACT
+
+#ifdef __mips_hard_float
+#define FP_INIT_ROUNDMODE			\
+do {						\
+  _FPU_GETCW (_fcw);				\
+} while (0)
+
+#define FP_HANDLE_EXCEPTIONS			\
+do {						\
+  if (__builtin_expect (_fex, 0))		\
+    _FPU_SETCW (_fcw | _fex);			\
+} while (0)
+#else
+#define FP_INIT_ROUNDMODE	_fcw = 0 /* no exceptions; FP_RND_NEAREST */
+#endif
diff --git a/sysdeps/riscv/setjmp.S b/sysdeps/riscv/setjmp.S
new file mode 100644
index 0000000..07559c5
--- /dev/null
+++ b/sysdeps/riscv/setjmp.S
@@ -0,0 +1,83 @@
+/* Copyright (C) 1996, 1997, 2000, 2002, 2003, 2004
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+ENTRY (_setjmp)
+  li	a1, 0
+  j	__sigsetjmp
+END (_setjmp)
+ENTRY (setjmp)
+  li	a1, 1
+  /* Fallthrough */
+END (setjmp)
+ENTRY (__sigsetjmp)
+	REG_S ra,  0*SZREG(a0)
+	REG_S s0,  1*SZREG(a0)
+	REG_S s1,  2*SZREG(a0)
+	REG_S s2,  3*SZREG(a0)
+	REG_S s3,  4*SZREG(a0)
+	REG_S s4,  5*SZREG(a0)
+	REG_S s5,  6*SZREG(a0)
+	REG_S s6,  7*SZREG(a0)
+	REG_S s7,  8*SZREG(a0)
+	REG_S s8,  9*SZREG(a0)
+	REG_S s9, 10*SZREG(a0)
+	REG_S s10,11*SZREG(a0)
+	REG_S s11,12*SZREG(a0)
+	REG_S sp, 13*SZREG(a0)
+	REG_S tp, 14*SZREG(a0)
+
+#ifdef __riscv_hard_float
+	frsr a3
+
+	fsd  fs0, 16*SZREG+ 0*8(a0)
+	fsd  fs1, 16*SZREG+ 1*8(a0)
+	fsd  fs2, 16*SZREG+ 2*8(a0)
+	fsd  fs3, 16*SZREG+ 3*8(a0)
+	fsd  fs4, 16*SZREG+ 4*8(a0)
+	fsd  fs5, 16*SZREG+ 5*8(a0)
+	fsd  fs6, 16*SZREG+ 6*8(a0)
+	fsd  fs7, 16*SZREG+ 7*8(a0)
+	fsd  fs8, 16*SZREG+ 8*8(a0)
+	fsd  fs9, 16*SZREG+ 9*8(a0)
+	fsd  fs10,16*SZREG+10*8(a0)
+	fsd  fs11,16*SZREG+11*8(a0)
+	fsd  fs12,16*SZREG+12*8(a0)
+	fsd  fs13,16*SZREG+13*8(a0)
+	fsd  fs14,16*SZREG+14*8(a0)
+	fsd  fs15,16*SZREG+15*8(a0)
+
+	REG_S a3, 15*SZREG(a0)
+#endif
+
+#if defined NOT_IN_libc && defined IS_IN_rtld
+  /* In ld.so we never save the signal mask.  */
+  li v0, 0
+  ret
+#else
+  /* Make a tail call to __sigjmp_save; it takes the same args.  */
+  j __sigjmp_save
+#endif
+
+
+END(__sigsetjmp)
+
+weak_alias(_setjmp, __GI__setjmp)
diff --git a/sysdeps/riscv/sgidefs.h b/sysdeps/riscv/sgidefs.h
new file mode 100644
index 0000000..34a6e61
--- /dev/null
+++ b/sysdeps/riscv/sgidefs.h
@@ -0,0 +1,41 @@
+/* Copyright (C) 1996, 1997, 1998, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ralf Baechle <ralf@gnu.org>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SGIDEFS_H
+#define _SGIDEFS_H	1
+
+/*
+ * Subprogram calling convention
+ */
+#ifndef _ABIO32
+# define _ABIO32		1
+#endif
+#define _RISCV_SIM_ABI32		_ABIO32
+
+#ifndef _ABIN32
+# define _ABIN32		2
+#endif
+#define _RISCV_SIM_NABI32	_ABIN32
+
+#ifndef _ABI64
+# define _ABI64			3
+#endif
+#define _RISCV_SIM_ABI64		_ABI64
+
+#endif /* sgidefs.h */
diff --git a/sysdeps/riscv/soft-fp/sfp-machine.h b/sysdeps/riscv/soft-fp/sfp-machine.h
new file mode 100644
index 0000000..3b2a40f
--- /dev/null
+++ b/sysdeps/riscv/soft-fp/sfp-machine.h
@@ -0,0 +1,47 @@
+#define _FP_W_TYPE_SIZE		32
+#define _FP_W_TYPE		unsigned long
+#define _FP_WS_TYPE		signed long
+#define _FP_I_TYPE		long
+
+#define _FP_MUL_MEAT_S(R,X,Y)				\
+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_D(R,X,Y)				\
+  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_Q(R,X,Y)				\
+  _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)
+
+#define _FP_DIV_MEAT_S(R,X,Y)	_FP_DIV_MEAT_1_udiv_norm(S,R,X,Y)
+#define _FP_DIV_MEAT_D(R,X,Y)	_FP_DIV_MEAT_2_udiv(D,R,X,Y)
+#define _FP_DIV_MEAT_Q(R,X,Y)	_FP_DIV_MEAT_4_udiv(Q,R,X,Y)
+
+#define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
+#define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1), -1
+#define _FP_NANFRAC_Q		((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
+#define _FP_NANSIGN_S		0
+#define _FP_NANSIGN_D		0
+#define _FP_NANSIGN_Q		0
+
+#define _FP_KEEPNANFRACP 1
+/* From my experiments it seems X is chosen unless one of the
+   NaNs is sNaN,  in which case the result is NANSIGN/NANFRAC.  */
+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)			\
+  do {								\
+    if ((_FP_FRAC_HIGH_RAW_##fs(X) |				\
+	 _FP_FRAC_HIGH_RAW_##fs(Y)) & _FP_QNANBIT_##fs)		\
+      {								\
+	R##_s = _FP_NANSIGN_##fs;				\
+        _FP_FRAC_SET_##wc(R,_FP_NANFRAC_##fs);			\
+      }								\
+    else							\
+      {								\
+	R##_s = X##_s;						\
+        _FP_FRAC_COPY_##wc(R,X);				\
+      }								\
+    R##_c = FP_CLS_NAN;						\
+  } while (0)
+
+#define FP_EX_INVALID           (1 << 4)
+#define FP_EX_DIVZERO           (1 << 3)
+#define FP_EX_OVERFLOW          (1 << 2)
+#define FP_EX_UNDERFLOW         (1 << 1)
+#define FP_EX_INEXACT           (1 << 0)
diff --git a/sysdeps/riscv/stackinfo.h b/sysdeps/riscv/stackinfo.h
new file mode 100644
index 0000000..7a5e3e0
--- /dev/null
+++ b/sysdeps/riscv/stackinfo.h
@@ -0,0 +1,34 @@
+/* Copyright (C) 2000, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* This file contains a bit of information about the stack allocation
+   of the processor.  */
+
+#ifndef _STACKINFO_H
+#define _STACKINFO_H	1
+
+#include <elf.h>
+
+/* On MIPS the stack grows down.  */
+#define _STACK_GROWS_DOWN	1
+
+/* Default to an executable stack.  PF_X can be overridden if PT_GNU_STACK is
+ * present, but it is presumed absent.  */
+#define DEFAULT_STACK_PERMS (PF_R|PF_W|PF_X)
+
+#endif	/* stackinfo.h */
diff --git a/sysdeps/riscv/start.S b/sysdeps/riscv/start.S
new file mode 100644
index 0000000..55deb45
--- /dev/null
+++ b/sysdeps/riscv/start.S
@@ -0,0 +1,98 @@
+/* Startup code compliant to the ELF Mips ABI.
+   Copyright (C) 1995, 1997, 2000, 2001, 2002, 2003, 2004
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file. (The GNU Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define __ASSEMBLY__ 1
+#include <entry.h>
+#include <sgidefs.h>
+#include <sys/asm.h>
+
+#ifndef ENTRY_POINT
+#error ENTRY_POINT needs to be defined for start.S on MIPS/ELF.
+#endif
+
+/* This is the canonical entry point, usually the first thing in the text
+   segment.  The SVR4/Mips ABI (pages 3-31, 3-32) says that when the entry
+   point runs, most registers' values are unspecified, except for:
+
+   v0 ($2)	Contains a function pointer to be registered with `atexit'.
+		This is how the dynamic linker arranges to have DT_FINI
+		functions called for shared libraries that have been loaded
+		before this code runs.
+
+   sp ($29)	The stack contains the arguments and environment:
+		0(%esp)			argc
+		4(%esp)			argv[0]
+		...
+		(4*argc)(%esp)		NULL
+		(4*(argc+1))(%esp)	envp[0]
+		...
+					NULL
+   ra ($31)	The return address register is set to zero so that programs
+		that search backword through stack frames recognize the last
+		stack frame.
+*/
+
+
+/* We need to call:
+   __libc_start_main (int (*main) (int, char **, char **), int argc,
+		      char **argv, void (*init) (void), void (*fini) (void),
+		      void (*rtld_fini) (void), void *stack_end)
+*/
+	
+	.text
+	.globl ENTRY_POINT
+	.type ENTRY_POINT,@function
+ENTRY_POINT:
+	la    gp, _gp
+	la    a0, main
+	REG_L a1, 0(sp)      /* argc */
+	addi  a2, sp, SZREG  /* argv */
+	andi  sp, sp, ALMASK /* Align stack. */
+	la    a3, __libc_csu_init
+	la    a4, __libc_csu_fini
+	move  a5, v0  /* rtld_fini */
+	move  a6, sp  /* stack_end */
+	
+	jump  __libc_start_main
+
+/* Define a symbol for the first piece of initialized data.  */
+	.data
+	.globl __data_start
+__data_start:
+	.long 0
+	.weak data_start
+	data_start = __data_start
diff --git a/sysdeps/riscv/strcmp.S b/sysdeps/riscv/strcmp.S
new file mode 100644
index 0000000..2db21ea
--- /dev/null
+++ b/sysdeps/riscv/strcmp.S
@@ -0,0 +1,129 @@
+# Artisanally coded in California by A. Shell Waterman
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+#if BYTE_ORDER != LITTLE_ENDIAN
+# error
+#endif
+
+ENTRY(strcmp)
+  or    v1, a0, a1
+  li    t2, -1
+  and   v1, v1, SZREG-1
+  li    v0, 0
+  bnez  v1, .Lmisaligned
+
+#if SZREG == 4
+  li t3, 0x7f7f7f7f
+#else
+  ld t3, mask
+#endif
+
+  .macro check_one_word i n
+    REG_L a2, \i*SZREG(a0)
+    REG_L a3, \i*SZREG(a1)
+
+    and   t0, a2, t3
+    or    t1, a2, t3
+    add   t0, t0, t3
+    or    t0, t0, t1
+
+    bne   t0, t2, .Lnull\i
+    .if \i+1-\n
+      bne   a2, a3, .Lmismatch
+    .else
+      add   a0, a0, \n*SZREG
+      add   a1, a1, \n*SZREG
+      beq   a2, a3, .Lloop
+      # fall through to .Lmismatch
+    .endif
+  .endm
+
+  .macro foundnull i n
+    .ifne \i
+      .Lnull\i:
+      add   a0, a0, \i*SZREG
+      add   a1, a1, \i*SZREG
+      .ifeq \i-1
+        .Lnull0:
+      .endif
+      bne   a2, a3, .Lmisaligned
+      ret
+    .endif
+  .endm
+
+.Lloop:
+  # examine full words
+  check_one_word 0 4
+  check_one_word 1 4
+  check_one_word 2 4
+  check_one_word 3 4
+  # backwards branch to .Lloop contained above
+
+.Lmismatch:
+  # words don't match, but a2 has no null byte.
+#ifdef __riscv64
+  sll   a0, a2, 48
+  sll   a1, a3, 48
+  bne   a0, a1, .Lmismatch_upper
+  sll   a0, a2, 32
+  sll   a1, a3, 32
+  bne   a0, a1, .Lmismatch_upper
+#endif
+  sll   a0, a2, 16
+  sll   a1, a3, 16
+  bne   a0, a1, .Lmismatch_upper
+
+  srl   a0, a2, 8*SZREG-16
+  srl   a1, a3, 8*SZREG-16
+  sub   v0, a0, a1
+  and   v1, v0, 0xff
+  bnez  v1, 1f
+  ret
+
+.Lmismatch_upper:
+  srl   a0, a0, 8*SZREG-16
+  srl   a1, a1, 8*SZREG-16
+  sub   v0, a0, a1
+  and   v1, v0, 0xff
+  bnez  v1, 1f
+  ret
+
+1:and   a0, a0, 0xff
+  and   a1, a1, 0xff
+  sub   v0, a0, a1
+  ret
+
+.Lmisaligned:
+  # misaligned
+  lbu   v0, 0(a0)
+  lbu   v1, 0(a1)
+  add   a0, a0, 1
+  add   a1, a1, 1
+  bne   v0, v1, 1f
+  bnez  v0, .Lmisaligned
+
+1:
+  sub   v0, v0, v1
+  ret
+
+  # cases in which a null byte was detected
+  foundnull 0, 4
+  foundnull 1, 4
+  foundnull 2, 4
+  foundnull 3, 4
+
+END(strcmp)
+
+weak_alias(strcmp, __GI_strcmp)
+
+#if SZREG == 8
+#ifdef __PIC__
+.section .rodata.cst8,"aM",@progbits,8
+#else
+.section .srodata.cst8,"aM",@progbits,8
+#endif
+.align 3
+mask: .8byte 0x7f7f7f7f7f7f7f7f
+#endif
diff --git a/sysdeps/riscv/strcpy.c b/sysdeps/riscv/strcpy.c
new file mode 100644
index 0000000..c01c506
--- /dev/null
+++ b/sysdeps/riscv/strcpy.c
@@ -0,0 +1,54 @@
+#include <string.h>
+#include <stdint.h>
+
+#undef strcpy
+
+char* strcpy(char* dst, const char* src)
+{
+  char* dst0 = dst;
+
+  int misaligned = ((uintptr_t)dst | (uintptr_t)src) & (sizeof(long)-1);
+  if (__builtin_expect(!misaligned, 1))
+  {
+    long* ldst = (long*)dst;
+    const long* lsrc = (const long*)src;
+
+    while (!__libc_detect_null(*lsrc))
+      *ldst++ = *lsrc++;
+
+    dst = (char*)ldst;
+    src = (const char*)lsrc;
+
+    char c0 = src[0];
+    char c1 = src[1];
+    char c2 = src[2];
+    if (!(*dst++ = c0)) return dst0;
+    if (!(*dst++ = c1)) return dst0;
+    char c3 = src[3];
+    if (!(*dst++ = c2)) return dst0;
+    if (sizeof(long) == 4) goto out;
+    char c4 = src[4];
+    if (!(*dst++ = c3)) return dst0;
+    char c5 = src[5];
+    if (!(*dst++ = c4)) return dst0;
+    char c6 = src[6];
+    if (!(*dst++ = c5)) return dst0;
+    if (!(*dst++ = c6)) return dst0;
+
+out:
+    *dst++ = 0;
+    return dst0;
+  }
+
+  char ch;
+  do
+  {
+    ch = *src;
+    src++;
+    dst++;
+    *(dst-1) = ch;
+  } while(ch);
+
+  return dst0;
+}
+libc_hidden_def(strcpy)
diff --git a/sysdeps/riscv/strlen.c b/sysdeps/riscv/strlen.c
new file mode 100644
index 0000000..2630f46
--- /dev/null
+++ b/sysdeps/riscv/strlen.c
@@ -0,0 +1,38 @@
+#include <string.h>
+#include <stdint.h>
+
+#undef strlen
+
+size_t strlen(const char* str)
+{
+  const char* start = str;
+
+  if (__builtin_expect((uintptr_t)str & (sizeof(long)-1), 0)) do
+  {
+    char ch = *str;
+    str++;
+    if (!ch)
+      return str - start - 1;
+  } while ((uintptr_t)str & (sizeof(long)-1));
+
+  unsigned long* ls = (unsigned long*)str;
+  while (!__libc_detect_null(*ls++))
+    ;
+  asm volatile ("" : "+r"(ls)); /* prevent "optimization" */
+
+  str = (const char*)ls;
+  size_t ret = str - start, sl = sizeof(long);
+
+  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
+  if (c0 == 0)            return ret + 0 - sl;
+  if (c1 == 0)            return ret + 1 - sl;
+  if (c2 == 0)            return ret + 2 - sl;
+  if (sl == 4 || c3 == 0) return ret + 3 - sl;
+
+  c0 = str[4-sl], c1 = str[5-sl], c2 = str[6-sl], c3 = str[7-sl];
+  if (c0 == 0)            return ret + 4 - sl;
+  if (c1 == 0)            return ret + 5 - sl;
+  if (c2 == 0)            return ret + 6 - sl;
+                          return ret + 7 - sl;
+}
+libc_hidden_def(strlen)
diff --git a/sysdeps/riscv/sys/asm.h b/sysdeps/riscv/sys/asm.h
new file mode 100644
index 0000000..fc30999
--- /dev/null
+++ b/sysdeps/riscv/sys/asm.h
@@ -0,0 +1,69 @@
+/* copyright (c) 1997, 1998, 2002, 2003, 2004, 2005
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ralf Baechle <ralf@gnu.org>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_ASM_H
+#define _SYS_ASM_H
+
+/* 
+ * Macros to handle different pointer/register sizes for 32/64-bit code
+ */
+#ifdef __riscv64
+# define PTR .dword
+# define PTRLOG 3
+# define SZREG	8
+# define REG_S sd
+# define REG_L ld
+#else
+# define PTR .word
+# define PTRLOG 2
+# define SZREG	4
+# define REG_S sw
+# define REG_L lw
+#endif
+
+/*
+ * LEAF - declare leaf routine
+ */
+#define	LEAF(symbol)	\
+		.globl	symbol;                         \
+		.align	2;                              \
+		.type	symbol,@function;               \
+symbol:
+
+/*
+ * NESTED - declare nested routine entry point
+ */
+#define	NESTED(symbol, framesize, rpc) LEAF(symbol)
+
+/*
+ * END - mark end of function
+ */
+#ifndef END
+# define END(function)                                   \
+		.size	function,.-function
+#endif
+
+/*
+ * Stack alignment
+ */
+#define ALSZ	15
+#define ALMASK	~15
+
+#endif /* sys/asm.h */
diff --git a/sysdeps/riscv/tcb-offsets.sym b/sysdeps/riscv/tcb-offsets.sym
new file mode 100644
index 0000000..e0e71dc
--- /dev/null
+++ b/sysdeps/riscv/tcb-offsets.sym
@@ -0,0 +1,11 @@
+#include <sysdep.h>
+#include <tls.h>
+
+--
+
+-- Abuse tls.h macros to derive offsets relative to the thread register.
+#define thread_offsetof(mem)	(long)(offsetof(struct pthread, mem) - TLS_TCB_OFFSET - TLS_PRE_TCB_SIZE)
+
+MULTIPLE_THREADS_OFFSET		thread_offsetof (header.multiple_threads)
+PID_OFFSET			thread_offsetof (pid)
+TID_OFFSET			thread_offsetof (tid)
diff --git a/sysdeps/riscv/tst-audit.h b/sysdeps/riscv/tst-audit.h
new file mode 100644
index 0000000..ac011fc
--- /dev/null
+++ b/sysdeps/riscv/tst-audit.h
@@ -0,0 +1,33 @@
+/* Definitions for testing PLT entry/exit auditing.  ARM version.
+
+   Copyright (C) 2005 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sgidefs.h>
+
+#if _RISCV_SIM == _ABI32
+#define pltenter la_mips_n32_gnu_pltenter
+#define pltexit la_mips_n32_gnu_pltexit
+#else
+#define pltenter la_mips_n64_gnu_pltenter
+#define pltexit la_mips_n64_gnu_pltexit
+#endif
+#define La_regs La_mips_64_regs
+#define La_retval La_mips_64_retval
+#define int_retval lrv_v0
diff --git a/sysdeps/unix/riscv/rt-sysdep.c b/sysdeps/unix/riscv/rt-sysdep.c
new file mode 100644
index 0000000..3ff5595
--- /dev/null
+++ b/sysdeps/unix/riscv/rt-sysdep.c
@@ -0,0 +1 @@
+#include <sysdep.c>
diff --git a/sysdeps/unix/riscv/sysdep.c b/sysdeps/unix/riscv/sysdep.c
new file mode 100644
index 0000000..308eced
--- /dev/null
+++ b/sysdeps/unix/riscv/sysdep.c
@@ -0,0 +1,43 @@
+/* Copyright (C) 1992, 1993, 1994, 1997, 1998, 1999, 2000, 2002, 2003 
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Brendan Kehoe (brendan@zen.org).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <errno.h>
+
+long __syscall_error()
+{
+  register long v0 asm("v0");
+
+  /* Referencing errno may call a function, clobbering v0. */
+  long errno_val = -v0;
+
+#if defined (EWOULDBLOCK_sys) && EWOULDBLOCK_sys != EAGAIN
+	/* We translate the system's EWOULDBLOCK error into EAGAIN.
+	   The GNU C library always defines EWOULDBLOCK==EAGAIN.
+	   EWOULDBLOCK_sys is the original number.  */
+
+  if (errno_val == EWOULDBLOCK_sys)
+    errno_val = EAGAIN;
+#endif
+
+  errno = errno_val;
+
+  return -1;
+}
diff --git a/sysdeps/unix/riscv/sysdep.h b/sysdeps/unix/riscv/sysdep.h
new file mode 100644
index 0000000..910afd5
--- /dev/null
+++ b/sysdeps/unix/riscv/sysdep.h
@@ -0,0 +1,72 @@
+/* Copyright (C) 1992, 1995, 1997, 1999, 2000, 2002, 2003, 2004
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Brendan Kehoe (brendan@zen.org).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdeps/unix/sysdep.h>
+
+#ifdef __ASSEMBLER__
+
+#include <sys/asm.h>
+
+#define ENTRY(name) LEAF(name)
+
+#undef END
+#define	END(function)                                   \
+		.size	function,.-function
+
+#define ret	ret
+
+#undef PSEUDO_END
+#define PSEUDO_END(sym) .size sym,.-sym
+
+#define PSEUDO_NOERRNO(name, syscall_name, args)	\
+  .align 2;						\
+  ENTRY(name)						\
+  li v0, SYS_ify(syscall_name);				\
+  scall
+
+#undef PSEUDO_END_NOERRNO
+#define PSEUDO_END_NOERRNO(sym) .size sym,.-sym
+
+#define ret_NOERRNO ret
+
+#define PSEUDO_ERRVAL(name, syscall_name, args) \
+  PSEUDO_NOERRNO(name, syscall_name, args)
+
+#undef PSEUDO_END_ERRVAL
+#define PSEUDO_END_ERRVAL(sym) PSEUDO_END_NOERRNO(sym)
+
+#define ret_ERRVAL ret
+
+#define r0	v0
+#define r1	v1
+#define MOVE(x,y)	move y , x
+
+#define L(label) .L ## label
+
+#define PSEUDO(name, syscall_name, args) \
+  .align 2;							\
+  99: j __syscall_error;					\
+  ENTRY(name)							\
+  li v0, SYS_ify(syscall_name);					\
+  scall;							\
+  bltz v0, 99b;							\
+L(syse1):
+
+#endif
diff --git a/sysdeps/unix/sysv/linux/riscv/Implies b/sysdeps/unix/sysv/linux/riscv/Implies
new file mode 100644
index 0000000..0f2fab4
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/Implies
@@ -0,0 +1,5 @@
+unix/sysv/linux/generic
+riscv/nptl
+
+# This needs to change to support rv32
+unix/sysv/linux/riscv/rv64
diff --git a/sysdeps/unix/sysv/linux/riscv/Makefile b/sysdeps/unix/sysv/linux/riscv/Makefile
new file mode 100644
index 0000000..396053f
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/Makefile
@@ -0,0 +1,13 @@
+ifeq ($(subdir),elf)
+ifeq ($(build-shared),yes)
+# This is needed for DSO loading from static binaries.
+sysdep-dl-routines += dl-static
+sysdep_routines += dl-static
+sysdep-rtld-routines += dl-static
+endif
+endif
+
+ifeq ($(subdir),stdlib)
+sysdep_routines += __start_context
+gen-as-const-headers += ucontext_i.sym
+endif
diff --git a/sysdeps/unix/sysv/linux/riscv/Versions b/sysdeps/unix/sysv/linux/riscv/Versions
new file mode 100644
index 0000000..a56322a
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/Versions
@@ -0,0 +1,40 @@
+ld {
+  GLIBC_PRIVATE {
+    # used for loading by static libraries
+    _dl_var_init;
+  }
+}
+libc {
+  # The comment lines with "#errlist-compat" are magic; see errlist-compat.awk.
+  # When you get an error from errlist-compat.awk, you need to add a new
+  # version here.  Don't do this blindly, since this means changing the ABI
+  # for all GNU/Linux configurations.
+
+  GLIBC_2.0 {
+    #errlist-compat	123
+    _sys_errlist; sys_errlist; _sys_nerr; sys_nerr;
+
+    # Exception handling support functions from libgcc
+    __register_frame; __register_frame_table; __deregister_frame;
+    __frame_state_for; __register_frame_info_table;
+
+    # Needed by gcc:
+    _flush_cache;
+
+    # c*
+    cachectl; cacheflush;
+
+    # s*
+    sysmips;
+  }
+  GLIBC_2.2 {
+    #errlist-compat	1134
+    _sys_errlist; sys_errlist; _sys_nerr; sys_nerr;
+
+    # _*
+    _test_and_set;
+  }
+  GLIBC_2.11 {
+    fallocate64;
+  }
+}
diff --git a/sysdeps/unix/sysv/linux/riscv/____longjmp_chk.S b/sysdeps/unix/sysv/linux/riscv/____longjmp_chk.S
new file mode 100644
index 0000000..e903c7e
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/____longjmp_chk.S
@@ -0,0 +1,2 @@
+#define __longjmp ____longjmp_chk
+#include <__longjmp.S>
diff --git a/sysdeps/unix/sysv/linux/riscv/__start_context.S b/sysdeps/unix/sysv/linux/riscv/__start_context.S
new file mode 100644
index 0000000..7408289
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/__start_context.S
@@ -0,0 +1,38 @@
+/* Modify saved context.
+   Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Maciej W. Rozycki <macro@codesourcery.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+#include "ucontext_i.h"
+
+	.text
+LEAF (__start_context)
+	move	a0, zero
+	beqz	s0, 1f
+
+	/* setcontext (ucp) */
+	move	a0, s0
+	jal	__setcontext
+	move	a0, v0
+
+1:	jal	HIDDEN_JUMPTARGET (exit)
+
+PSEUDO_END (__start_context)
diff --git a/sysdeps/unix/sysv/linux/riscv/arch-fork.h b/sysdeps/unix/sysv/linux/riscv/arch-fork.h
new file mode 100644
index 0000000..5f94537
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/arch-fork.h
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/arch-fork.h>
diff --git a/sysdeps/unix/sysv/linux/riscv/bits/atomic.h b/sysdeps/unix/sysv/linux/riscv/bits/atomic.h
new file mode 100644
index 0000000..82b9006
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/bits/atomic.h
@@ -0,0 +1,53 @@
+/* Low-level functions for atomic operations. Mips version.
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _LINUX_RISCV_BITS_ATOMIC_H
+#define _LINUX_RISCV_BITS_ATOMIC_H 1
+
+#include_next <bits/atomic.h>
+
+#ifndef __riscv_atomic
+
+#include <sys/syscall.h>
+#include <sysdep.h>
+
+#define __arch_compare_and_exchange_val_8_acq(mem, newval, oldval) \
+  (abort (), (__typeof (*mem)) 0)
+
+#define __arch_compare_and_exchange_val_16_acq(mem, newval, oldval) \
+  (abort (), (__typeof (*mem)) 0)
+
+/* The only basic operation needed is compare and exchange.  */
+#define __arch_compare_and_exchange_val_32_acq(mem, newval, oldval) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    INTERNAL_SYSCALL (sysriscv, __err, 4,				      \
+		      RISCV_ATOMIC_CMPXCHG, mem, oldval, newval);	      \
+  })
+
+#define __arch_compare_and_exchange_val_64_acq(mem, newval, oldval) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    INTERNAL_SYSCALL (sysriscv, __err, 4,				      \
+		      RISCV_ATOMIC_CMPXCHG64, mem, oldval, newval);	      \
+  })
+
+#endif /* __riscv_atomic */
+
+#endif /* bits/atomic.h */
diff --git a/sysdeps/unix/sysv/linux/riscv/bits/endian.h b/sysdeps/unix/sysv/linux/riscv/bits/endian.h
new file mode 100644
index 0000000..6caa0bd
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/bits/endian.h
@@ -0,0 +1,16 @@
+/* The MIPS architecture has selectable endianness.
+   Linux/MIPS exists in two both little and big endian flavours and we
+   want to be able to share the installed headerfiles between both,
+   so we define __BYTE_ORDER based on GCC's predefines.  */
+
+#ifndef _ENDIAN_H
+# error "Never use <bits/endian.h> directly; include <endian.h> instead."
+#endif
+
+#ifdef __RISCVEB__
+# define __BYTE_ORDER __BIG_ENDIAN
+#else
+# ifdef __RISCVEL__
+#  define __BYTE_ORDER __LITTLE_ENDIAN
+# endif
+#endif
diff --git a/sysdeps/unix/sysv/linux/riscv/bits/mman.h b/sysdeps/unix/sysv/linux/riscv/bits/mman.h
new file mode 100644
index 0000000..8ee3d96
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/bits/mman.h
@@ -0,0 +1,38 @@
+/* Definitions for POSIX memory map interface.  Linux/MIPS version.
+   Copyright (C) 1997, 2000, 2003, 2004, 2005, 2006, 2009, 2011
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_MMAN_H
+# error "Never use <bits/mman.h> directly; include <sys/mman.h> instead."
+#endif
+
+#ifdef __USE_MISC
+# define MAP_GROWSDOWN	0x00100		/* Stack-like segment.  */
+# define MAP_DENYWRITE	0x00800		/* ETXTBSY */
+# define MAP_EXECUTABLE	0x01000		/* Mark it as an executable.  */
+# define MAP_LOCKED	0x02000		/* Lock the mapping.  */
+# define MAP_NORESERVE	0x04000		/* Don't check for reservations.  */
+# define MAP_POPULATE	0x08000		/* Populate (prefault) pagetables.  */
+# define MAP_NONBLOCK	0x10000		/* Do not block on IO.  */
+# define MAP_STACK	0x20000		/* Allocation is for a stack.  */
+# define MAP_HUGETLB	0x40000		/* Create huge page mapping.  */
+#endif
+
+/* Include generic Linux declarations.  */
+#include <bits/mman-linux.h>
diff --git a/sysdeps/unix/sysv/linux/riscv/bits/sigcontext.h b/sysdeps/unix/sysv/linux/riscv/bits/sigcontext.h
new file mode 100644
index 0000000..3e9d7f0
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/bits/sigcontext.h
@@ -0,0 +1,33 @@
+/* Copyright (C) 1996, 1997, 1998, 2003, 2004, 2006 Free Software
+   Foundation, Inc.  This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_SIGCONTEXT_H
+#define _BITS_SIGCONTEXT_H 1
+
+#if !defined _SIGNAL_H && !defined _SYS_UCONTEXT_H
+# error "Never use <bits/sigcontext.h> directly; include <signal.h> instead."
+#endif
+
+struct sigcontext {
+  /* gregs[0] holds the program counter. */
+  unsigned long gregs[32];
+  double fpregs[32];
+  unsigned long fsr;
+};
+
+#endif
diff --git a/sysdeps/unix/sysv/linux/riscv/clone.S b/sysdeps/unix/sysv/linux/riscv/clone.S
new file mode 100644
index 0000000..67b2146
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/clone.S
@@ -0,0 +1,119 @@
+/* Copyright (C) 1996, 1997, 2000, 2003, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ralf Baechle <ralf@linux-mips.org>, 1996.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* clone() is even more special than fork() as it mucks with stacks
+   and invokes a function in the right context after its all over.  */
+
+#include <sys/asm.h>
+#include <sysdep.h>
+#define _ERRNO_H	1
+#include <bits/errno.h>
+#ifdef RESET_PID
+#include <tls.h>
+#include "tcb-offsets.h"
+#endif
+
+#define CLONE_VM      0x00000100
+#define CLONE_THREAD  0x00010000
+
+/* int clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg,
+	     void *parent_tidptr, void *tls, void *child_tidptr) */
+
+	.text
+LEAF(__clone)
+
+	/* Sanity check arguments.  */
+	li		v0,EINVAL
+	beqz		a0,L(error)	/* No NULL function pointers.  */
+	beqz		a1,L(error)	/* No NULL stack pointers.  */
+
+	addi		a1,a1,-32		/* Reserve argument save space.  */
+	REG_S		a0,0(a1)	/* Save function pointer.  */
+	REG_S		a3,SZREG(a1)	/* Save argument pointer.  */
+#ifdef RESET_PID
+	REG_S		a2,(SZREG*2)(a1)	/* Save clone flags.  */
+#endif
+
+	move		a0,a2
+
+	/* Shuffle in the last three arguments - arguments 5, 6, and 7 to
+	   this function, but arguments 3, 4, and 5 to the syscall.  */
+	move		a2,a4
+	move		a3,a5
+	move		a4,a6
+
+	/* Do the system call */
+	li		v0,__NR_clone
+	scall
+
+	bltz		v0,L(error)
+	beqz		v0,L(thread_start)
+
+	/* Successful return from the parent */
+	ret
+
+	/* Something bad happened -- no child created */
+L(error):
+	j		__syscall_error
+	END(__clone)
+
+/* Load up the arguments to the function.  Put this block of code in
+   its own function so that we can terminate the stack trace with our
+   debug info.  */
+
+ENTRY(__thread_start)
+L(thread_start):
+	/* The stackframe has been created on entry of clone().  */
+
+#ifdef RESET_PID
+	/* Check and see if we need to reset the PID.  */
+	REG_L		a0,(SZREG*2)(sp)
+	li		a1,CLONE_THREAD
+	and		a1,a0,a1
+	beqz		a1,L(restore_pid)
+L(donepid):
+#endif
+
+	/* Restore the arg for user's function.  */
+	REG_L		v0,0(sp)	/* Function pointer.  */
+	REG_L		a0,SZREG(sp)	/* Argument pointer.  */
+
+	/* Call the user's function.  */
+	jalr		v0
+
+	/* Call _exit rather than doing it inline for breakpoint purposes.  */
+	move		a0,v0
+	j		_exit
+
+#ifdef RESET_PID
+L(restore_pid):
+	and		a1,a0,CLONE_VM
+	li		v0,-1
+	bnez		a1,L(gotpid)
+	li		v0,__NR_getpid
+	scall
+L(gotpid):
+	sw		v0,PID_OFFSET(tp)
+	sw		v0,TID_OFFSET(tp)
+	b		L(donepid)
+#endif
+
+	END(__thread_start)
+
+weak_alias (__clone, clone)
diff --git a/sysdeps/unix/sysv/linux/riscv/configure b/sysdeps/unix/sysv/linux/riscv/configure
new file mode 100644
index 0000000..038022f
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/configure
@@ -0,0 +1,28 @@
+# This file is generated from configure.in by Autoconf.  DO NOT EDIT!
+ # Local configure fragment for sysdeps/unix/sysv/linux/riscv.
+
+case "$prefix" in
+/usr | /usr/)
+  # 32-bit libraries on bi-arch platforms go in /lib32 instead of /lib.
+  # Allow earlier configure scripts to handle libc_cv_slibdir, libdir,
+  # and libc_cv_localedir.
+  test -n "$libc_cv_slibdir" || \
+  case $machine in
+  riscv/rv32* )
+    libc_cv_slibdir="/lib32"
+    if test "$libdir" = '${exec_prefix}/lib'; then
+      libdir='${exec_prefix}/lib32';
+      # Locale data can be shared between 32bit and 64bit libraries
+      libc_cv_localedir='${exec_prefix}/lib/locale'
+    fi
+    ;;
+  *)
+    libc_cv_slibdir="/lib"
+    ;;
+  esac
+esac
+
+if test -z "$arch_minimum_kernel"; then
+  arch_minimum_kernel=2.4.1
+  libc_cv_gcc_unwind_find_fde=no
+fi
diff --git a/sysdeps/unix/sysv/linux/riscv/configure.in b/sysdeps/unix/sysv/linux/riscv/configure.in
new file mode 100644
index 0000000..87d0cd3
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/configure.in
@@ -0,0 +1,29 @@
+sinclude(./aclocal.m4)dnl Autoconf lossage
+GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
+# Local configure fragment for sysdeps/unix/sysv/linux/riscv.
+
+case "$prefix" in
+/usr | /usr/)
+  # 32-bit libraries on bi-arch platforms go in /lib32 instead of /lib.
+  # Allow earlier configure scripts to handle libc_cv_slibdir, libdir,
+  # and libc_cv_localedir.
+  test -n "$libc_cv_slibdir" || \
+  case $machine in
+  riscv/rv32* )
+    libc_cv_slibdir="/lib32"
+    if test "$libdir" = '${exec_prefix}/lib'; then
+      libdir='${exec_prefix}/lib32';
+      # Locale data can be shared between 32bit and 64bit libraries
+      libc_cv_localedir='${exec_prefix}/lib/locale'
+    fi
+    ;;
+  *)
+    libc_cv_slibdir="/lib"
+    ;;
+  esac
+esac
+
+if test -z "$arch_minimum_kernel"; then
+  arch_minimum_kernel=2.4.1
+  libc_cv_gcc_unwind_find_fde=no
+fi
diff --git a/sysdeps/unix/sysv/linux/riscv/dl-cache.h b/sysdeps/unix/sysv/linux/riscv/dl-cache.h
new file mode 100644
index 0000000..8ef4822
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/dl-cache.h
@@ -0,0 +1,45 @@
+/* Support for reading /etc/ld.so.cache files written by Linux ldconfig.
+   Copyright (C) 2003, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <ldconfig.h>
+
+#define add_system_dir(dir) \
+  do								\
+    {								\
+      size_t len = strlen (dir);				\
+      char path[len + 3];					\
+      memcpy (path, dir, len + 1);				\
+      if (len >= 6						\
+	  && (! memcmp (path + len - 6, "/lib64", 6)		\
+	      || ! memcmp (path + len - 6, "/lib32", 6)))	\
+	{							\
+	  len -= 2;						\
+	  path[len] = '\0';					\
+	}							\
+      add_dir (path);						\
+      if (len >= 4 && ! memcmp (path + len - 4, "/lib", 4))	\
+	{							\
+	  memcpy (path + len, "32", 3);				\
+	  add_dir (path);					\
+	  memcpy (path + len, "64", 3);				\
+	  add_dir (path);					\
+	}							\
+    } while (0)
+
+#include_next <dl-cache.h>
diff --git a/sysdeps/unix/sysv/linux/riscv/dl-static.c b/sysdeps/unix/sysv/linux/riscv/dl-static.c
new file mode 100644
index 0000000..3a99e7e
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/dl-static.c
@@ -0,0 +1,92 @@
+/* Variable initialization.  MIPS version.
+   Copyright (C) 2001, 2002, 2003, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <ldsodefs.h>
+
+#ifdef SHARED
+
+void
+_dl_var_init (void *array[])
+{
+  /* It has to match "variables" below. */
+  enum
+    {
+      DL_PAGESIZE = 0
+    };
+
+  GLRO(dl_pagesize) = *((size_t *) array[DL_PAGESIZE]);
+}
+
+#else
+#include <bits/libc-lock.h>
+
+__libc_lock_define_initialized_recursive (static, _dl_static_lock)
+
+static void *variables[] =
+{
+  &GLRO(dl_pagesize)
+};
+
+static void
+_dl_unprotect_relro (struct link_map *l)
+{
+  ElfW(Addr) start = ((l->l_addr + l->l_relro_addr)
+		      & ~(GLRO(dl_pagesize) - 1));
+  ElfW(Addr) end = ((l->l_addr + l->l_relro_addr + l->l_relro_size)
+		    & ~(GLRO(dl_pagesize) - 1));
+
+  if (start != end)
+    __mprotect ((void *) start, end - start, PROT_READ | PROT_WRITE);
+}
+
+void
+_dl_static_init (struct link_map *l)
+{
+  struct link_map *rtld_map = l;
+  struct r_scope_elem **scope;
+  const ElfW(Sym) *ref = NULL;
+  lookup_t loadbase;
+  void (*f) (void *[]);
+  size_t i;
+
+  __libc_lock_lock_recursive (_dl_static_lock);
+
+  loadbase = _dl_lookup_symbol_x ("_dl_var_init", l, &ref, l->l_local_scope,
+				  NULL, 0, 1, NULL);
+  
+  for (scope = l->l_local_scope; *scope != NULL; scope++)
+    for (i = 0; i < (*scope)->r_nlist; i++)
+      if ((*scope)->r_list[i] == loadbase)
+	{
+	  rtld_map = (*scope)->r_list[i];
+	  break;
+	}
+
+  if (ref != NULL)
+    {
+      f = (void (*) (void *[])) DL_SYMBOL_ADDRESS (loadbase, ref);
+      _dl_unprotect_relro (rtld_map);
+      f (variables);
+      _dl_protect_relro (rtld_map);
+    }
+
+  __libc_lock_unlock_recursive (_dl_static_lock);
+}
+
+#endif
diff --git a/sysdeps/unix/sysv/linux/riscv/getcontext.S b/sysdeps/unix/sysv/linux/riscv/getcontext.S
new file mode 100644
index 0000000..c849ddd
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/getcontext.S
@@ -0,0 +1,86 @@
+/* Save current context.
+   Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Maciej W. Rozycki <macro@codesourcery.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+#include "ucontext_i.h"
+
+/* int getcontext (ucontext_t *ucp) */
+
+	.text
+LEAF (__getcontext)
+	REG_S	ra, MCONTEXT_PC(a0)
+	REG_S	ra, ( 1 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s0, ( 2 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s1, ( 3 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s2, ( 4 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s3, ( 5 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s4, ( 6 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s5, ( 7 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s6, ( 8 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s7, ( 9 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s8, (10 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s9, (11 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s10,(12 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s11,(13 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	sp, (14 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	tp, (15 * SZREG + MCONTEXT_GREGS)(a0)
+
+#ifdef __riscv_hard_float
+	frsr v1
+
+	fsd	fs0, ( 0 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs1, ( 1 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs2, ( 2 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs3, ( 3 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs4, ( 4 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs5, ( 5 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs6, ( 6 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs7, ( 7 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs8, ( 8 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs9, ( 9 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs10,(10 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs11,(11 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs12,(12 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs13,(13 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs14,(14 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs15,(15 * 8 + MCONTEXT_FPREGS)(a0)
+
+	sw	v1, MCONTEXT_FSR(a0)
+#endif /* __mips_hard_float */
+
+/* rt_sigprocmask (SIG_BLOCK, NULL, &ucp->uc_sigmask, _NSIG8) */
+	li	a3, _NSIG8
+	add     a2, a0, UCONTEXT_SIGMASK
+	move	a1, zero
+	li	a0, SIG_BLOCK
+
+	li	v0, SYS_ify (rt_sigprocmask)
+	scall
+	bltz	v0, 99f
+
+	ret
+
+99:	j	__syscall_error
+
+PSEUDO_END (__getcontext)
+
+weak_alias (__getcontext, getcontext)
diff --git a/sysdeps/unix/sysv/linux/riscv/getmsg.c b/sysdeps/unix/sysv/linux/riscv/getmsg.c
new file mode 100644
index 0000000..3a1fa08
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/getmsg.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/getmsg.c>
diff --git a/sysdeps/unix/sysv/linux/riscv/kernel-features.h b/sysdeps/unix/sysv/linux/riscv/kernel-features.h
new file mode 100644
index 0000000..9283b3f
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/kernel-features.h
@@ -0,0 +1,29 @@
+/* Copyright (C) 2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __ASSUME_ACCEPT4_SYSCALL	1
+#define __ASSUME_RECVMMSG_SYSCALL	1
+#define __ASSUME_SENDMMSG_SYSCALL	1
+
+#include_next <kernel-features.h>
+
+/* asm-generic architectures do not have the utimes syscall.  */
+#undef __ASSUME_UTIMES
+
+/* Define this if your 32-bit syscall API requires 64-bit register
+   pairs to start with an even-number register.  */
+#define __ASSUME_ALIGNED_REGISTER_PAIRS	1
diff --git a/sysdeps/unix/sysv/linux/riscv/ldsodefs.h b/sysdeps/unix/sysv/linux/riscv/ldsodefs.h
new file mode 100644
index 0000000..8d5efec
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/ldsodefs.h
@@ -0,0 +1,33 @@
+/* Run-time dynamic linker data structures for loaded ELF shared objects. MIPS.
+   Copyright (C) 2001, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_LDSODEFS_H
+
+/* Get the real definitions.  */
+#include_next <ldsodefs.h>
+
+/* Now define our stuff.  */
+
+/* We need special support to initialize DSO loaded for statically linked
+   binaries.  */
+extern void _dl_static_init (struct link_map *map);
+#undef DL_STATIC_INIT
+#define DL_STATIC_INIT(map) _dl_static_init (map)
+
+#endif /* ldsodefs.h */
diff --git a/sysdeps/unix/sysv/linux/riscv/libc-abis b/sysdeps/unix/sysv/linux/riscv/libc-abis
new file mode 100644
index 0000000..f180a03
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/libc-abis
@@ -0,0 +1,13 @@
+# See the copy of this file in libc for detailed explanations.  This
+# copy needs to include all libc definitions applicable to MIPS; only
+# one copy will be used.
+#
+# Feature Name	Configuration
+# ------------	-------------
+#
+# MIPS PLTs.
+MIPS_PLT	mips*-*-linux*
+#
+# Unique symbol definitions for C++.
+# Architecture independent, all ELF targets (== all targets)
+UNIQUE
diff --git a/sysdeps/unix/sysv/linux/riscv/makecontext.c b/sysdeps/unix/sysv/linux/riscv/makecontext.c
new file mode 100644
index 0000000..a0f0304
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/makecontext.c
@@ -0,0 +1,43 @@
+#include <sysdep.h>
+#include <sys/asm.h>
+#include <sys/ucontext.h>
+#include <stdarg.h>
+#include <assert.h>
+
+void __makecontext (ucontext_t *ucp, void (*func) (void), int argc,
+		    long a0, long a1, long a2, long a3,
+		    long a4, ...)
+{
+  extern void __start_context(void);
+  long i, sp;
+  va_list vl;
+
+  va_start(vl, a4);
+  assert(REG_NARGS == 8);
+
+  /* Set up the stack. */
+  sp = ((long)ucp->uc_stack.ss_sp + ucp->uc_stack.ss_size) & ALMASK;
+
+  /* Put args in a0-a7, then put any remaining args on the stack. */
+  ucp->uc_mcontext.gregs[REG_A0 + 0] = a0;
+  ucp->uc_mcontext.gregs[REG_A0 + 1] = a1;
+  ucp->uc_mcontext.gregs[REG_A0 + 2] = a2;
+  ucp->uc_mcontext.gregs[REG_A0 + 3] = a3;
+  ucp->uc_mcontext.gregs[REG_A0 + 4] = a4;
+  if (__builtin_expect(argc > 5, 0))
+    {
+      long reg_args = argc < REG_NARGS ? argc : REG_NARGS;
+      sp = (sp - (argc - reg_args) * sizeof(long)) & ALMASK;
+      for (i = 5; i < reg_args; i++)
+        ucp->uc_mcontext.gregs[REG_A0 + i] = va_arg(vl, long);
+      for (i = 0; i < argc - reg_args; i++)
+        ((long*)sp)[i] = va_arg(vl, long);
+    }
+
+  ucp->uc_mcontext.gregs[REG_S0] = (long)ucp->uc_link;
+  ucp->uc_mcontext.gregs[REG_SP] = sp;
+  ucp->uc_mcontext.gregs[REG_PC] = (long)func;
+  ucp->uc_mcontext.gregs[REG_RA] = (long)&__start_context;
+}
+
+weak_alias (__makecontext, makecontext)
diff --git a/sysdeps/unix/sysv/linux/riscv/profil-counter.h b/sysdeps/unix/sysv/linux/riscv/profil-counter.h
new file mode 100644
index 0000000..8a6a0bc
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/profil-counter.h
@@ -0,0 +1,2 @@
+/* We can use the ix86 version.  */
+#include <sysdeps/unix/sysv/linux/i386/profil-counter.h>
diff --git a/sysdeps/unix/sysv/linux/riscv/putmsg.c b/sysdeps/unix/sysv/linux/riscv/putmsg.c
new file mode 100644
index 0000000..ebc1680
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/putmsg.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/putmsg.c>
diff --git a/sysdeps/unix/sysv/linux/riscv/register-dump.h b/sysdeps/unix/sysv/linux/riscv/register-dump.h
new file mode 100644
index 0000000..4b498a5
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/register-dump.h
@@ -0,0 +1,65 @@
+/* Dump registers.
+   Copyright (C) 2000, 2001, 2002, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <string.h>
+#include <_itoa.h>
+
+static void
+hexvalue (unsigned long int value, char *buf, size_t len)
+{
+  char *cp = _itoa_word (value, buf + len, 16, 0);
+  while (cp > buf)
+    *--cp = '0';
+}
+
+#define REGDUMP_NREGS 32
+#define REGDUMP_PER_LINE (80 / (__WORDSIZE/4 + 4))
+
+static void
+register_dump (int fd, struct ucontext *ctx)
+{
+  int i;
+  char regvalue[__WORDSIZE/4 + 1];
+  char str[82 * ((REGDUMP_NREGS + REGDUMP_PER_LINE - 1) / REGDUMP_PER_LINE)];
+
+  static const char names[REGDUMP_NREGS][4] = {
+    "pc", "ra", "s0", "s1", "s2", "s3", "s4", "s5",
+    "s6", "s7", "s8", "s9", "sA", "sB", "sp", "tp",
+    "v0", "v1", "a0", "a1", "a2", "a3", "a4", "a5",
+    "a6", "a7", "t0", "t1", "t2", "t3", "t4", "gp"
+  };
+
+  str[0] = 0;
+  for (i = 0; i < REGDUMP_NREGS; i++)
+    {
+      strcat (str, names[i]);
+      strcat (str, " ");
+      hexvalue (ctx->uc_mcontext.gregs[i], regvalue, __WORDSIZE/4);
+      strcat (str, regvalue);
+
+      if ((i + 1) % REGDUMP_PER_LINE == 0)
+	strcat (str, "\n");
+    }
+
+  write (fd, str, strlen (str));
+}
+
+#define REGISTER_DUMP register_dump (fd, ctx)
diff --git a/sysdeps/unix/sysv/linux/riscv/rv32/lockf64.c b/sysdeps/unix/sysv/linux/riscv/rv32/lockf64.c
new file mode 100644
index 0000000..a88f5a7
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/rv32/lockf64.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/lockf64.c>
diff --git a/sysdeps/unix/sysv/linux/riscv/rv32/readahead.c b/sysdeps/unix/sysv/linux/riscv/rv32/readahead.c
new file mode 100644
index 0000000..80170c3
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/rv32/readahead.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/arm/readahead.c>
diff --git a/sysdeps/unix/sysv/linux/riscv/rv32/sync_file_range.c b/sysdeps/unix/sysv/linux/riscv/rv32/sync_file_range.c
new file mode 100644
index 0000000..4213dce
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/rv32/sync_file_range.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/mips/mips32/sync_file_range.c>
diff --git a/sysdeps/unix/sysv/linux/riscv/rv64/Implies b/sysdeps/unix/sysv/linux/riscv/rv64/Implies
new file mode 100644
index 0000000..8d91c80
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/rv64/Implies
@@ -0,0 +1 @@
+unix/sysv/linux/wordsize-64
diff --git a/sysdeps/unix/sysv/linux/riscv/rv64/Makefile b/sysdeps/unix/sysv/linux/riscv/rv64/Makefile
new file mode 100644
index 0000000..0a37c5b
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/rv64/Makefile
@@ -0,0 +1,9 @@
+ifeq ($(subdir),socket)
+CFLAGS-recv.c += -fexceptions
+CFLAGS-send.c += -fexceptions
+endif
+
+ifeq ($(subdir),nptl)
+CFLAGS-recv.c += -fexceptions
+CFLAGS-send.c += -fexceptions
+endif
diff --git a/sysdeps/unix/sysv/linux/riscv/rv64/ldconfig.h b/sysdeps/unix/sysv/linux/riscv/rv64/ldconfig.h
new file mode 100644
index 0000000..43fca83
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/rv64/ldconfig.h
@@ -0,0 +1,26 @@
+/* Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdeps/generic/ldconfig.h>
+
+#define SYSDEP_KNOWN_INTERPRETER_NAMES \
+  { "/lib32/ld.so.1", FLAG_ELF_LIBC6 }, \
+  { "/lib/ld.so.1", FLAG_ELF_LIBC6 },
+#define SYSDEP_KNOWN_LIBRARY_NAMES \
+  { "libc.so.6", FLAG_ELF_LIBC6 },	\
+  { "libm.so.6", FLAG_ELF_LIBC6 },
diff --git a/sysdeps/unix/sysv/linux/riscv/rv64/ldd-rewrite.sed b/sysdeps/unix/sysv/linux/riscv/rv64/ldd-rewrite.sed
new file mode 100644
index 0000000..2c32732
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/rv64/ldd-rewrite.sed
@@ -0,0 +1 @@
+s_^\(RTLDLIST=\)\(.*lib\)\(\|32\|64\)\(/[^/]*\.so\.[0-9.]*\)[ 	]*$_\1"\232\4 \264\4 \2\4"_
diff --git a/sysdeps/unix/sysv/linux/riscv/setcontext.S b/sysdeps/unix/sysv/linux/riscv/setcontext.S
new file mode 100644
index 0000000..07b6f71
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/setcontext.S
@@ -0,0 +1,100 @@
+/* Set current context.
+   Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Maciej W. Rozycki <macro@codesourcery.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+#include "ucontext_i.h"
+
+/* int setcontext (const ucontext_t *ucp) */
+
+	.text
+LEAF (__setcontext)
+
+	mv	t0, a0					/* t0 <- ucp */
+
+/* rt_sigprocmask (SIG_SETMASK, &ucp->uc_sigmask, NULL, _NSIG8) */
+	li	a3, _NSIG8
+	move	a2, zero
+	add     a1, a0, UCONTEXT_SIGMASK
+	li	a0, SIG_SETMASK
+
+	li	v0, SYS_ify (rt_sigprocmask)
+	scall
+
+	bltz	v0, 99f
+
+#ifdef __riscv_hard_float
+	lw	v1, MCONTEXT_FSR(t0)
+
+	fld	fs0, ( 0 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs1, ( 1 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs2, ( 2 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs3, ( 3 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs4, ( 4 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs5, ( 5 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs6, ( 6 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs7, ( 7 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs8, ( 8 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs9, ( 9 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs10,(10 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs11,(11 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs12,(12 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs13,(13 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs14,(14 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs15,(15 * 8 + MCONTEXT_FPREGS)(t0)
+
+	fssr	v1
+#endif /* __mips_hard_float */
+
+	/* Note the contents of argument registers will be random
+	   unless makecontext() has been called.  */
+	REG_L	v1, MCONTEXT_PC(t0)
+	REG_L	ra, ( 1 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s0, ( 2 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s1, ( 3 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s2, ( 4 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s3, ( 5 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s4, ( 6 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s5, ( 7 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s6, ( 8 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s7, ( 9 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s8, (10 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s9, (11 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s10,(12 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s11,(13 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	sp, (14 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	tp, (15 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a0, (18 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a1, (19 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a2, (20 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a3, (21 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a4, (22 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a5, (23 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a6, (24 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a7, (25 * SZREG + MCONTEXT_GREGS)(t0)
+
+	jr	v1
+
+99:	j	__syscall_error
+
+PSEUDO_END (__setcontext)
+
+weak_alias (__setcontext, setcontext)
diff --git a/sysdeps/unix/sysv/linux/riscv/sigcontextinfo.h b/sysdeps/unix/sysv/linux/riscv/sigcontextinfo.h
new file mode 100644
index 0000000..ea01f8e
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/sigcontextinfo.h
@@ -0,0 +1,29 @@
+/* Copyright (C) 2000, 2001, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/ucontext.h>
+
+#define SIGCONTEXT siginfo_t *_si, struct ucontext *
+#define SIGCONTEXT_EXTRA_ARGS _si,
+#define GET_PC(ctx)	((void *) ctx->uc_mcontext.gregs[REG_PC])
+#define GET_FRAME(ctx)	((void *) ctx->uc_mcontext.gregs[REG_S0])
+#define GET_STACK(ctx)	((void *) ctx->uc_mcontext.gregs[REG_SP])
+
+#define CALL_SIGHANDLER(handler, signo, ctx) \
+  (handler)((signo), SIGCONTEXT_EXTRA_ARGS (ctx))
diff --git a/sysdeps/unix/sysv/linux/riscv/socket.S b/sysdeps/unix/sysv/linux/riscv/socket.S
new file mode 100644
index 0000000..1f66cd4
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/socket.S
@@ -0,0 +1,91 @@
+/* Copyright (C) 1997, 1998, 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Miguel de Icaza <miguel@gnu.ai.mit.edu>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep-cancel.h>
+#include <socketcall.h>
+
+#define P(a, b) P2(a, b)
+#define P2(a, b) a##b
+
+#ifndef NARGS
+#ifdef socket
+#error NARGS not defined
+#endif
+#define NARGS 3
+#endif
+
+	.text
+/* The socket-oriented system calls are handled unusually in Linux.
+   They are all gated through the single `socketcall' system call number.
+   `socketcall' takes two arguments: the first is the subcode, specifying
+   which socket function is being called; and the second is a pointer to
+   the arguments to the specific function.
+
+   The .S files for the other calls just #define socket and #include this.  */
+
+#ifndef __socket
+# ifndef NO_WEAK_ALIAS
+#  define __socket P(__,socket)
+# else
+#  define __socket socket
+# endif
+#endif
+
+LEAF (__socket)
+
+	addi  sp, sp, -SZREG*NARGS
+
+	REG_S a0, 0*SZREG(sp)
+	REG_S a1, 1*SZREG(sp)
+#if NARGS > 2
+	REG_S a2, 2*SZREG(sp)
+#if NARGS > 3
+	REG_S a3, 3*SZREG(sp)
+#if NARGS > 4
+	REG_S a4, 4*SZREG(sp)
+#if NARGS > 5
+	REG_S a5, 5*SZREG(sp)
+#endif
+#endif
+#endif
+#endif
+
+#if defined NEED_CANCELLATION && defined CENABLE
+	SINGLE_THREAD_P(a0)
+	bnez  a0, 1f
+#endif
+	li    a0, P(SOCKOP_,socket)   /* arg 1: socket subfunction */
+	move  a1, sp			/* arg 2: parameter block */
+	li    v0, SYS_ify (rt_sigprocmask)
+	scall
+
+	addi  sp, sp, SZREG*NARGS
+	bltz	v0, 99f
+
+#if defined NEED_CANCELLATION && defined CENABLE
+1:sbreak
+#endif
+
+99: 	j	__syscall_error
+
+END (__socket)
+
+#ifndef NO_WEAK_ALIAS
+weak_alias (__socket, socket)
+#endif
diff --git a/sysdeps/unix/sysv/linux/riscv/swapcontext.S b/sysdeps/unix/sysv/linux/riscv/swapcontext.S
new file mode 100644
index 0000000..76ec343
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/swapcontext.S
@@ -0,0 +1,138 @@
+/* Save and set current context.
+   Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Maciej W. Rozycki <macro@codesourcery.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+#include "ucontext_i.h"
+
+/* int swapcontext (ucontext_t *oucp, const ucontext_t *ucp) */
+
+LEAF (__swapcontext)
+	mv	t0, a1					/* t0 <- ucp */
+
+	REG_S	ra, MCONTEXT_PC(a0)
+	REG_S	ra, ( 1 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s0, ( 2 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s1, ( 3 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s2, ( 4 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s3, ( 5 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s4, ( 6 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s5, ( 7 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s6, ( 8 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s7, ( 9 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s8, (10 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s9, (11 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s10,(12 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s11,(13 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	sp, (14 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	tp, (15 * SZREG + MCONTEXT_GREGS)(a0)
+
+#ifdef __riscv_hard_float
+	frsr v1
+
+	fsd	fs0, ( 0 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs1, ( 1 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs2, ( 2 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs3, ( 3 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs4, ( 4 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs5, ( 5 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs6, ( 6 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs7, ( 7 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs8, ( 8 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs9, ( 9 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs10,(10 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs11,(11 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs12,(12 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs13,(13 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs14,(14 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs15,(15 * 8 + MCONTEXT_FPREGS)(a0)
+
+	sw	v1, MCONTEXT_FSR(a0)
+#endif /* __mips_hard_float */
+
+/* rt_sigprocmask (SIG_SETMASK, &ucp->uc_sigmask, NULL, _NSIG8) */
+	li	a3, _NSIG8
+	add	a2, a0, UCONTEXT_SIGMASK
+	add     a1, a1, UCONTEXT_SIGMASK
+	li	a0, SIG_SETMASK
+
+	li	v0, SYS_ify (rt_sigprocmask)
+	scall
+
+	bltz	v0, 99f
+
+#ifdef __riscv_hard_float
+	lw	v1, MCONTEXT_FSR(t0)
+
+	fld	fs0, ( 0 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs1, ( 1 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs2, ( 2 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs3, ( 3 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs4, ( 4 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs5, ( 5 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs6, ( 6 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs7, ( 7 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs8, ( 8 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs9, ( 9 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs10,(10 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs11,(11 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs12,(12 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs13,(13 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs14,(14 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs15,(15 * 8 + MCONTEXT_FPREGS)(t0)
+
+	fssr	v1
+#endif /* __mips_hard_float */
+
+	/* Note the contents of argument registers will be random
+	   unless makecontext() has been called.  */
+	REG_L	v1, MCONTEXT_PC(t0)
+	REG_L	ra, ( 1 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s0, ( 2 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s1, ( 3 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s2, ( 4 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s3, ( 5 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s4, ( 6 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s5, ( 7 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s6, ( 8 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s7, ( 9 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s8, (10 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s9, (11 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s10,(12 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s11,(13 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	sp, (14 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	tp, (15 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a0, (18 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a1, (19 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a2, (20 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a3, (21 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a4, (22 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a5, (23 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a6, (24 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a7, (25 * SZREG + MCONTEXT_GREGS)(t0)
+
+	jr	v1
+
+99:	j	__syscall_error
+
+PSEUDO_END (__swapcontext)
+
+weak_alias (__swapcontext, swapcontext)
diff --git a/sysdeps/unix/sysv/linux/riscv/sys/procfs.h b/sysdeps/unix/sysv/linux/riscv/sys/procfs.h
new file mode 100644
index 0000000..ce11419
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/sys/procfs.h
@@ -0,0 +1,128 @@
+/* Copyright (C) 1996, 1997, 1999, 2000, 2002, 2003, 2004
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_PROCFS_H
+#define _SYS_PROCFS_H	1
+
+/* This is somehow modelled after the file of the same name on SysVr4
+   systems.  It provides a definition of the core file format for ELF
+   used on Linux.  */
+
+#include <features.h>
+#include <sgidefs.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/user.h>
+#include <sgidefs.h>
+
+/* ELF register definitions */
+#define ELF_NGREG	45
+#define ELF_NFPREG	33
+
+#if _RISCV_SIM == _ABIN32
+__extension__ typedef unsigned long long elf_greg_t;
+#else
+typedef unsigned long elf_greg_t;
+#endif
+typedef elf_greg_t elf_gregset_t[ELF_NGREG];
+
+typedef double elf_fpreg_t;
+typedef elf_fpreg_t elf_fpregset_t[ELF_NFPREG];
+
+__BEGIN_DECLS
+
+struct elf_siginfo
+  {
+    int si_signo;			/* Signal number.  */
+    int si_code;			/* Extra code.  */
+    int si_errno;			/* Errno.  */
+  };
+
+
+/* Definitions to generate Intel SVR4-like core files.  These mostly
+   have the same names as the SVR4 types with "elf_" tacked on the
+   front to prevent clashes with linux definitions, and the typedef
+   forms have been avoided.  This is mostly like the SVR4 structure,
+   but more Linuxy, with things that Linux does not support and which
+   gdb doesn't really use excluded.  Fields present but not used are
+   marked with "XXX".  */
+struct elf_prstatus
+  {
+    struct elf_siginfo pr_info;		/* Info associated with signal.  */
+    short int pr_cursig;		/* Current signal.  */
+#if _RISCV_SIM == _ABIN32
+    __extension__ unsigned long long int pr_sigpend;
+    __extension__ unsigned long long int pr_sighold;
+#else
+    unsigned long int pr_sigpend;	/* Set of pending signals.  */
+    unsigned long int pr_sighold;	/* Set of held signals.  */
+#endif
+    __pid_t pr_pid;
+    __pid_t pr_ppid;
+    __pid_t pr_pgrp;
+    __pid_t pr_sid;
+    struct timeval pr_utime;		/* User time.  */
+    struct timeval pr_stime;		/* System time.  */
+    struct timeval pr_cutime;		/* Cumulative user time.  */
+    struct timeval pr_cstime;		/* Cumulative system time.  */
+    elf_gregset_t pr_reg;		/* GP registers.  */
+    int pr_fpvalid;			/* True if math copro being used.  */
+  };
+
+
+#define ELF_PRARGSZ     (80)    /* Number of chars for args */
+
+struct elf_prpsinfo
+  {
+    char pr_state;			/* Numeric process state.  */
+    char pr_sname;			/* Char for pr_state.  */
+    char pr_zomb;			/* Zombie.  */
+    char pr_nice;			/* Nice val.  */
+#if _RISCV_SIM == _ABIN32
+    __extension__ unsigned long long int pr_flag;
+#else
+    unsigned long int pr_flag;		/* Flags.  */
+#endif
+    long pr_uid;
+    long pr_gid;
+    int pr_pid, pr_ppid, pr_pgrp, pr_sid;
+    /* Lots missing */
+    char pr_fname[16];			/* Filename of executable.  */
+    char pr_psargs[ELF_PRARGSZ];	/* Initial part of arg list.  */
+  };
+
+
+/* Addresses.  */
+typedef void *psaddr_t;
+
+/* Register sets.  Linux has different names.  */
+typedef elf_gregset_t prgregset_t;
+typedef elf_fpregset_t prfpregset_t;
+
+/* We don't have any differences between processes and threads,
+   therefore habe only ine PID type.  */
+typedef __pid_t lwpid_t;
+
+
+typedef struct elf_prstatus prstatus_t;
+typedef struct elf_prpsinfo prpsinfo_t;
+
+__END_DECLS
+
+#endif	/* sys/procfs.h */
diff --git a/sysdeps/unix/sysv/linux/riscv/sys/ucontext.h b/sysdeps/unix/sysv/linux/riscv/sys/ucontext.h
new file mode 100644
index 0000000..b81ce52
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/sys/ucontext.h
@@ -0,0 +1,66 @@
+/* Copyright (C) 1997, 1998, 2000, 2003, 2004, 2006, 2009 Free Software
+   Foundation, Inc.  This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Don't rely on this, the interface is currently messed up and may need to
+   be broken to be fixed.  */
+#ifndef _SYS_UCONTEXT_H
+#define _SYS_UCONTEXT_H	1
+
+#include <features.h>
+#include <signal.h>
+
+/* We need the signal context definitions even if they are not used
+   included in <signal.h>.  */
+#include <bits/sigcontext.h>
+
+/* Type for general register.  Even in o32 we assume 64-bit registers,
+   like the kernel.  */
+__extension__ typedef unsigned long long int greg_t;
+
+/* Number of general registers.  */
+#define NGREG	32
+#define NFPREG	32
+
+#define REG_PC 0
+#define REG_RA 1
+#define REG_S0 2
+#define REG_A0 18
+#define REG_NARGS 8
+#define REG_SP 14
+#define REG_TP 15
+
+/* Container for all general registers.  */
+typedef greg_t gregset_t[NGREG];
+
+/* Container for all FPU registers.  */
+typedef double fpregset_t[NFPREG];
+
+/* Context to describe whole processor state.  */
+typedef struct sigcontext mcontext_t;
+
+/* Userlevel context.  */
+typedef struct ucontext
+  {
+    unsigned long int uc_flags;
+    struct ucontext *uc_link;
+    stack_t uc_stack;
+    mcontext_t uc_mcontext;
+    __sigset_t uc_sigmask;
+  } ucontext_t;
+
+#endif /* sys/ucontext.h */
diff --git a/sysdeps/unix/sysv/linux/riscv/sys/user.h b/sysdeps/unix/sysv/linux/riscv/sys/user.h
new file mode 100644
index 0000000..c871f1a
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/sys/user.h
@@ -0,0 +1 @@
+/* This file is not needed, but in practice gdb might try to include it.  */
diff --git a/sysdeps/unix/sysv/linux/riscv/syscall.c b/sysdeps/unix/sysv/linux/riscv/syscall.c
new file mode 100644
index 0000000..ea5e209
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/syscall.c
@@ -0,0 +1,36 @@
+/* Copyright (C) 2001, 2002, 2003, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+long syscall (long syscall_number, long arg1, long arg2, long arg3,
+	      long arg4, long arg5, long arg6, long arg7)
+{
+  long ret, err; 
+
+  ret = INTERNAL_SYSCALL_NCS(syscall_number, err, 7, arg1, arg2, arg3, arg4,
+			     arg5, arg6, arg7);
+
+  if (INTERNAL_SYSCALL_ERROR_P(ret, err))
+    {
+      extern long __syscall_error() attribute_hidden;
+      return __syscall_error();
+    }
+
+  return ret;
+}
diff --git a/sysdeps/unix/sysv/linux/riscv/sysdep.h b/sysdeps/unix/sysv/linux/riscv/sysdep.h
new file mode 100644
index 0000000..fa92ccb
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/sysdep.h
@@ -0,0 +1,234 @@
+/* Copyright (C) 2011-2014
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _LINUX_RISCV_SYSDEP_H
+#define _LINUX_RISCV_SYSDEP_H 1
+
+#include <sysdeps/unix/riscv/sysdep.h>
+#include <sysdeps/unix/sysv/linux/generic/sysdep.h>
+#include <tls.h>
+
+/* For Linux we can use the system call table in the header file
+	/usr/include/asm/unistd.h
+   of the kernel.  But these symbols do not follow the SYS_* syntax
+   so we have to redefine the `SYS_ify' macro here.  */
+#undef SYS_ify
+#ifdef __STDC__
+# define SYS_ify(syscall_name)	__NR_##syscall_name
+#else
+# define SYS_ify(syscall_name)	__NR_/**/syscall_name
+#endif
+
+#ifndef __ASSEMBLER__
+
+/* In order to get __set_errno() definition in INLINE_SYSCALL.  */
+#include <errno.h>
+
+/* Define a macro which expands into the inline wrapper code for a system
+   call.  */
+#undef INLINE_SYSCALL
+#define INLINE_SYSCALL(name, nr, args...)				\
+  ({ INTERNAL_SYSCALL_DECL(err);					\
+     long result_var = INTERNAL_SYSCALL (name, err, nr, args);		\
+     if ( INTERNAL_SYSCALL_ERROR_P (result_var, err) )			\
+       {								\
+	 __set_errno (INTERNAL_SYSCALL_ERRNO (result_var, err));	\
+	 result_var = -1L;						\
+       }								\
+     result_var; })
+
+#undef INTERNAL_SYSCALL_DECL
+#define INTERNAL_SYSCALL_DECL(err) do { } while (0)
+
+#undef INTERNAL_SYSCALL_ERROR_P
+#define INTERNAL_SYSCALL_ERROR_P(val, err)   ((long) (val) < 0)
+
+#undef INTERNAL_SYSCALL_ERRNO
+#define INTERNAL_SYSCALL_ERRNO(val, err)     (-val)
+
+#undef INTERNAL_SYSCALL
+#define INTERNAL_SYSCALL(name, err, nr, args...) \
+	internal_syscall##nr (SYS_ify (name), err, args)
+
+#undef INTERNAL_SYSCALL_NCS
+#define INTERNAL_SYSCALL_NCS(number, err, nr, args...) \
+	internal_syscall##nr (number, err, args)
+
+#define internal_syscall0(number, err, dummy...)			\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("v0") = number;				\
+	__asm__ volatile ( 						\
+	"scall\n\t" 							\
+	: "+r" (__v0)							\
+	: "r" (__v0)							\
+	: __SYSCALL_CLOBBERS); 						\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall1(number, err, arg0)				\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("v0") = number;				\
+	register long __a0 asm("a0") = (long) (arg0); 			\
+	__asm__ volatile ( 						\
+	"scall\n\t" 							\
+	: "+r" (__v0)							\
+	: "r" (__v0), "r"(__a0)						\
+	: __SYSCALL_CLOBBERS); 						\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall2(number, err, arg0, arg1)	    		\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("v0") = number;				\
+	register long __a0 asm("a0") = (long) (arg0); 			\
+	register long __a1 asm("a1") = (long) (arg1); 			\
+	__asm__ volatile ( 						\
+	"scall\n\t" 							\
+	: "+r" (__v0)							\
+	: "r" (__v0), "r"(__a0), "r"(__a1)				\
+	: __SYSCALL_CLOBBERS); 						\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall3(number, err, arg0, arg1, arg2)      		\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("v0") = number;				\
+	register long __a0 asm("a0") = (long) (arg0); 			\
+	register long __a1 asm("a1") = (long) (arg1); 			\
+	register long __a2 asm("a2") = (long) (arg2); 			\
+	__asm__ volatile ( 						\
+	"scall\n\t" 							\
+	: "+r" (__v0)							\
+	: "r" (__v0), "r"(__a0), "r"(__a1), "r"(__a2)			\
+	: __SYSCALL_CLOBBERS); 						\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall4(number, err, arg0, arg1, arg2, arg3)	  \
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("v0") = number;				\
+	register long __a0 asm("a0") = (long) (arg0); 			\
+	register long __a1 asm("a1") = (long) (arg1); 			\
+	register long __a2 asm("a2") = (long) (arg2); 			\
+	register long __a3 asm("a3") = (long) (arg3);   		\
+	__asm__ volatile ( 						\
+	"scall\n\t" 							\
+	: "+r" (__v0)							\
+	: "r" (__v0), "r"(__a0), "r"(__a1), "r"(__a2), "r"(__a3)	\
+	: __SYSCALL_CLOBBERS); 						\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall5(number, err, arg0, arg1, arg2, arg3, arg4)    \
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("v0") = number;				\
+	register long __a0 asm("a0") = (long) (arg0); 			\
+	register long __a1 asm("a1") = (long) (arg1); 			\
+	register long __a2 asm("a2") = (long) (arg2); 			\
+	register long __a3 asm("a3") = (long) (arg3);   		\
+	register long __a4 asm("a4") = (long) (arg4);   		\
+	__asm__ volatile ( 						\
+	"scall\n\t" 							\
+	: "+r" (__v0)							\
+	: "r" (__v0), "r"(__a0), "r"(__a1), "r"(__a2), "r"(__a3), "r"(__a4)     \
+	: __SYSCALL_CLOBBERS); 						\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall6(number, err, arg0, arg1, arg2, arg3, arg4, arg5) \
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("v0") = number;				\
+	register long __a0 asm("a0") = (long) (arg0); 			\
+	register long __a1 asm("a1") = (long) (arg1); 			\
+	register long __a2 asm("a2") = (long) (arg2); 			\
+	register long __a3 asm("a3") = (long) (arg3);   		\
+	register long __a4 asm("a4") = (long) (arg4);   		\
+	register long __a5 asm("a5") = (long) (arg5);   		\
+	__asm__ volatile ( 						\
+	"scall\n\t" 							\
+	: "+r" (__v0)							\
+	: "r" (__v0), "r"(__a0), "r"(__a1), "r"(__a2), "r"(__a3), "r"(__a4), "r"(__a5)     \
+	: __SYSCALL_CLOBBERS); 						\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall7(number, err, arg0, arg1, arg2, arg3, arg4, arg5, arg6) \
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("v0") = number;				\
+	register long __a0 asm("a0") = (long) (arg0); 			\
+	register long __a1 asm("a1") = (long) (arg1); 			\
+	register long __a2 asm("a2") = (long) (arg2); 			\
+	register long __a3 asm("a3") = (long) (arg3);   		\
+	register long __a4 asm("a4") = (long) (arg4);   		\
+	register long __a5 asm("a5") = (long) (arg5);   		\
+	register long __a6 asm("a6") = (long) (arg6);   		\
+	__asm__ volatile ( 						\
+	"scall\n\t" 							\
+	: "+r" (__v0)							\
+	: "r" (__v0), "r"(__a0), "r"(__a1), "r"(__a2), "r"(__a3), "r"(__a4), "r"(__a5), "r"(__a6)     \
+	: __SYSCALL_CLOBBERS); 						\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define __SYSCALL_CLOBBERS "v1", "memory"
+#endif /* ! __ASSEMBLER__ */
+
+/* Pointer mangling is not supported.  */
+#define PTR_MANGLE(var) (void) (var)
+#define PTR_DEMANGLE(var) (void) (var)
+
+#endif /* linux/mips/sysdep.h */
diff --git a/sysdeps/unix/sysv/linux/riscv/ucontext_i.sym b/sysdeps/unix/sysv/linux/riscv/ucontext_i.sym
new file mode 100644
index 0000000..67f50d4
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/ucontext_i.sym
@@ -0,0 +1,33 @@
+#include <inttypes.h>
+#include <signal.h>
+#include <stddef.h>
+#include <sys/ucontext.h>
+
+-- Constants used by the rt_sigprocmask call.
+
+SIG_BLOCK
+SIG_SETMASK
+
+_NSIG8				(_NSIG / 8)
+
+-- Offsets of the fields in the ucontext_t structure.
+#define ucontext(member)	offsetof (ucontext_t, member)
+#define stack(member)		ucontext (uc_stack.member)
+#define mcontext(member)	ucontext (uc_mcontext.member)
+
+UCONTEXT_FLAGS			ucontext (uc_flags)
+UCONTEXT_LINK			ucontext (uc_link)
+UCONTEXT_STACK			ucontext (uc_stack)
+UCONTEXT_MCONTEXT		ucontext (uc_mcontext)
+UCONTEXT_SIGMASK		ucontext (uc_sigmask)
+
+STACK_SP			stack (ss_sp)
+STACK_SIZE			stack (ss_size)
+STACK_FLAGS			stack (ss_flags)
+
+MCONTEXT_GREGS			mcontext (gregs)
+MCONTEXT_FPREGS			mcontext (fpregs)
+MCONTEXT_PC			mcontext (gregs)
+MCONTEXT_FSR			mcontext (fsr)
+
+UCONTEXT_SIZE			sizeof (ucontext_t)
diff --git a/sysdeps/unix/sysv/linux/riscv/vfork.S b/sysdeps/unix/sysv/linux/riscv/vfork.S
new file mode 100644
index 0000000..cc30fe5
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/vfork.S
@@ -0,0 +1,65 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* vfork() is just a special case of clone().  */
+
+#include <sys/asm.h>
+#include <sysdep.h>
+#include <asm/unistd.h>
+#include <sgidefs.h>
+
+#ifndef SAVE_PID
+#define SAVE_PID
+#endif
+
+#ifndef RESTORE_PID
+#define RESTORE_PID
+#endif
+
+
+/* int vfork() */
+
+	.text
+LEAF(__vfork)
+
+	SAVE_PID
+
+	li		a0, 0x4111	/* CLONE_VM | CLONE_VFORK | SIGCHLD */
+	move		a1, sp
+	li		a2, 0
+	li		a3, 0
+	li		a4, 0
+
+	/* Do the system call */
+	li		v0,__NR_clone
+	scall
+
+	bltz		v0,L(error)
+
+	RESTORE_PID
+
+	ret
+
+	/* Something bad happened -- no child created.  */
+L(error):
+	j		__syscall_error
+
+	END(__vfork)
+
+libc_hidden_def(__vfork)
+weak_alias (__vfork, vfork)
