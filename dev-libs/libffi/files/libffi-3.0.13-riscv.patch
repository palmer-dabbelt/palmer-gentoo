diff --git a/Makefile.am b/Makefile.am
index bf0156f..cb73a91 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -26,6 +26,8 @@ EXTRA_DIST = LICENSE ChangeLog.v1 ChangeLog.libgcj configure.host	\
 	 src/powerpc/asm.h src/powerpc/aix.S src/powerpc/darwin.S	\
 	 src/powerpc/aix_closure.S src/powerpc/darwin_closure.S		\
 	 src/powerpc/ffi_darwin.c src/powerpc/ffitarget.h		\
+	 src/riscv/ffi.c src/riscv/rv32.S				\
+	 src/riscv/rv64.S src/riscv/ffitarget.h				\
 	 src/s390/ffi.c src/s390/sysv.S src/s390/ffitarget.h		\
 	 src/sh/ffi.c src/sh/sysv.S src/sh/ffitarget.h src/sh64/ffi.c	\
 	 src/sh64/sysv.S src/sh64/ffitarget.h src/sparc/v8.S		\
@@ -116,6 +118,9 @@ endif
 if MIPS
 nodist_libffi_la_SOURCES += src/mips/ffi.c src/mips/o32.S src/mips/n32.S
 endif
+if RISCV
+nodist_libffi_la_SOURCES += src/riscv/ffi.c src/riscv/rv32.S src/riscv/rv64.S
+endif
 if BFIN
 nodist_libffi_la_SOURCES += src/bfin/ffi.c src/bfin/sysv.S
 endif
diff --git a/configure.ac b/configure.ac
index 0dc0675..d2dfff2 100644
--- a/configure.ac
+++ b/configure.ac
@@ -236,6 +236,10 @@ case "$host" in
   powerpc*-*-rtems*)
 	TARGET=POWERPC; TARGETDIR=powerpc
 	;;
+	
+  riscv | riscv-* | riscv64-*)
+    TARGET=RISCV; TARGETDIR=riscv;
+    ;;
 
   s390-*-* | s390x-*-*)
 	TARGET=S390; TARGETDIR=s390
@@ -253,8 +257,8 @@ case "$host" in
 	;;
 
   tile*-*)
-        TARGET=TILE; TARGETDIR=tile
-        ;;
+    TARGET=TILE; TARGETDIR=tile
+    ;;
 
   xtensa*-*)
 	TARGET=XTENSA; TARGETDIR=xtensa
@@ -269,6 +273,7 @@ if test $TARGETDIR = unknown; then
   AC_MSG_ERROR(["libffi has not been ported to $host."])
 fi
 
+AM_CONDITIONAL(RISCV, test x$TARGET = xRISCV)
 AM_CONDITIONAL(MIPS, test x$TARGET = xMIPS)
 AM_CONDITIONAL(BFIN, test x$TARGET = xBFIN)
 AM_CONDITIONAL(SPARC, test x$TARGET = xSPARC)
diff --git a/src/riscv/asm.py b/src/riscv/asm.py
new file mode 100644
index 0000000..55c3c33
--- /dev/null
+++ b/src/riscv/asm.py
@@ -0,0 +1,37 @@
+#!/bin/python
+
+def set_args_64(i):
+    return """
+####################
+## SET ARGUMENT """ + str(i) + """ ##
+####################
+
+set_arg""" + str(i) + """:
+    srli    t1, t0, FFI_FLAG_BITS_X""" + str(i) + """ # Shift to get the bits for this argument
+    andi    t1, t1, 3               # Mask out the bits for this argument
+    
+    # when its zero, it means its just a word-sized int/ptr
+    bne     t1, zero, set_arg""" + str(i) + """_float 
+    ld      a""" + str(i) + """, FFI_SIZEOF_ARG_X""" + str(i) + """(sp) # load argument
+    j       set_arg""" + str(i+1) + """
+    
+set_arg""" + str(i) + """_float:
+    addi    t1, t1, -1
+    
+    # when its zero, it means its just a word-sized float
+    bne     t1, zero, set_arg""" + str(i) + """_double
+    flw     fa""" + str(i) + """, FFI_SIZEOF_ARG_X""" + str(i) + """(sp) # load argument
+    j       set_arg""" + str(i+1) + """
+    
+set_arg""" + str(i) + """_double:
+    # otherwise it must be a double we're dealing with
+    fld     fa""" + str(i) + """, FFI_SIZEOF_ARG_X""" + str(i) + """(sp)
+"""
+
+def gen64_setargs_string():
+    setargs = ""
+    for i in range(8):
+        setargs += set_args_64(i)
+    return setargs
+
+print gen64_setargs_string()
\ No newline at end of file
diff --git a/src/riscv/ffi.c b/src/riscv/ffi.c
new file mode 100644
index 0000000..9e130a2
--- /dev/null
+++ b/src/riscv/ffi.c
@@ -0,0 +1,327 @@
+/* -----------------------------------------------------------------------
+   ffi.c - 2014 Michael Knyszek
+   
+   RISC-V 32-bit Foreign Function Interface 
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#include <stdlib.h>
+
+/* ffi_prep_args is called by the assembly routine once stack space
+   has been allocated for the function's arguments */
+
+static void ffi_prep_args(char *stack, extended_cif *ecif, int bytes, int flags)
+{
+    int i;
+    void **p_argv;
+    char *argp;
+    ffi_type **p_arg;
+    argp = stack;
+
+    memset(stack, 0, bytes);
+
+    if (ecif->cif->rtype->type == FFI_TYPE_STRUCT)
+    {
+        *(ffi_arg *) argp = (ffi_arg) ecif->rvalue;
+        argp += sizeof(ffi_arg);
+    }
+
+    p_argv = ecif->avalue;
+
+    for (i = 0, p_arg = ecif->cif->arg_types; i < ecif->cif->nargs; i++, p_arg++)
+    {
+        size_t z;
+        unsigned int a;
+
+        /* Align if necessary. */
+        a = (*p_arg)->alignment;
+        if (a < sizeof(ffi_arg))
+            a = sizeof(ffi_arg);
+
+        if ((a - 1) & (unsigned long) argp)
+        {
+            argp = (char *) ALIGN(argp, a);
+        }
+
+        z = (*p_arg)->size;
+        if (z <= sizeof(ffi_arg))
+        {
+            int type = (*p_arg)->type;
+            z = sizeof(ffi_arg);
+
+            /* The size of a pointer depends on the ABI */
+            if (type == FFI_TYPE_POINTER)
+            #ifdef __riscv64
+                type = FFI_TYPE_SINT64;
+            #else
+                type = FFI_TYPE_SINT32;
+            #endif
+            
+            if (i < 8 && (ecif->cif->abi == FFI_RV32_SOFT_FLOAT || ecif->cif->abi == FFI_RV64_SOFT_FLOAT))
+            {
+                switch (type)
+                {
+                    case FFI_TYPE_FLOAT:
+                        type = FFI_TYPE_UINT32;
+                        break;
+                    case FFI_TYPE_DOUBLE:
+                        type = FFI_TYPE_UINT64;
+                        break;
+                    default:
+                        break;
+                }
+            }
+            
+            switch (type)
+            {
+                case FFI_TYPE_SINT8:
+                    *(ffi_arg *)argp = *(SINT8 *)(* p_argv);
+                    break;
+
+                case FFI_TYPE_UINT8:
+                    *(ffi_arg *)argp = *(UINT8 *)(* p_argv);
+                    break;
+
+                case FFI_TYPE_SINT16:
+                    *(ffi_arg *)argp = *(SINT16 *)(* p_argv);
+                    break;
+
+                case FFI_TYPE_UINT16:
+                    *(ffi_arg *)argp = *(UINT16 *)(* p_argv);
+                    break;
+
+                case FFI_TYPE_SINT32:
+                    *(ffi_arg *)argp = *(SINT32 *)(* p_argv);
+                    break;
+
+                case FFI_TYPE_UINT32:
+                    *(ffi_arg *)argp = *(UINT32 *)(* p_argv);
+                    break;
+                    
+                case FFI_TYPE_SINT64:
+                    *(ffi_arg *)argp = *(SINT64 *)(* p_argv);
+                    break;
+
+                case FFI_TYPE_UINT64:
+                    *(ffi_arg *)argp = *(UINT64 *)(* p_argv);
+                    break;
+
+                case FFI_TYPE_FLOAT:
+                    *(float *) argp = *(float *)(* p_argv);
+                    break;
+                    
+                case FFI_TYPE_DOUBLE:
+                    *(double *) argp = *(double *)(* p_argv);
+                    break;
+
+                /* Handle structures.  */
+                default:
+                    memcpy(argp, *p_argv, (*p_arg)->size);
+                    break;
+            }
+        }
+        else
+        {
+            memcpy(argp, *p_argv, z);
+        }
+        
+        p_argv++;
+        argp += z;
+    }
+}
+
+/* Perform machine dependent cif processing */
+
+ffi_status ffi_prep_cif_machdep(ffi_cif *cif)
+{
+    int i;
+    unsigned int prev_dbl_size = 0;
+    cif->flags = 0;
+    
+    /* Set the first 8 existing argument types in the flag bit string
+     * 
+     * We only describe the two argument types we care about:
+     * - Whether or not its a float
+     * - Whether or not its a 64 bit type
+     * 
+     * This is is two bits per argument accounting for the first 16 bits
+     * of cif->flags.
+     * 
+     * The last 16 bits are just used to describe the return type
+     * 
+     * FFI_FLAG_BITS = 2
+     */
+    
+    for(i = 0; i < cif->nargs && i < 8; ++i)
+    {
+        #ifdef __riscv64
+        switch ((cif->arg_types)[i]->type)
+        {
+            case FFI_TYPE_FLOAT:
+                cif->flags += 1 << (FFI_FLAG_BITS * i);
+                
+                prev_dbl_size = 0;
+                break;
+                
+            case FFI_TYPE_DOUBLE:
+                cif->flags += 2 << (FFI_FLAG_BITS * i);
+                
+                prev_dbl_size = 0;
+                break;
+                
+            /*case FFI_TYPE_LONG_DOUBLE:
+                if (i == 7) break;
+                if (!prev_dbl_size && i % 2 != 0) ++i;
+                
+                cif->flags += 3 << (FFI_FLAG_BITS * i);
+                
+                ++i;
+                prev_dbl_size = 1;
+                break;
+            */    
+            default:
+                prev_dbl_size = 0;
+                break;
+        }
+        #else
+        switch ((cif->arg_types)[i]->type)
+        {
+            case FFI_TYPE_FLOAT:
+                cif->flags += 1 << (FFI_FLAG_BITS * i);
+                
+                prev_dbl_size = 0;
+                break;
+                
+            case FFI_TYPE_DOUBLE:
+                if (i == 7) break;
+                if (!prev_dbl_size && i % 2 != 0) ++i;
+                
+                cif->flags += 3 << (FFI_FLAG_BITS * i);
+                ++i;
+                
+                prev_dbl_size = 1;
+                break;
+                
+            case FFI_TYPE_SINT64:
+            case FFI_TYPE_UINT64:
+                if (i == 7) break;
+                if (!prev_dbl_size && i % 2 != 0) ++i;
+                
+                cif->flags += 2 << (FFI_FLAG_BITS * i);
+                ++i;
+                
+                prev_dbl_size = 1;
+                break;
+                
+            default:
+                prev_dbl_size = 0;
+                break;
+        }
+        #endif
+    }
+
+    /* Set the return type flag */
+
+    if (cif->abi == FFI_RV32_SOFT_FLOAT || cif->abi == FFI_RV64_SOFT_FLOAT)
+    {
+        switch (cif->rtype->type)
+        {
+        // long long is the same size as a word in riscv64
+        #ifndef __riscv64
+            case FFI_TYPE_SINT64:
+            case FFI_TYPE_UINT64:
+            case FFI_TYPE_DOUBLE:
+                cif->flags += FFI_TYPE_UINT64 << (FFI_FLAG_BITS * 8);
+                break;
+        #endif
+            default:
+                cif->flags += FFI_TYPE_INT << (FFI_FLAG_BITS * 8);
+                break;
+        }
+    }
+    else
+    {   
+        switch (cif->rtype->type)
+        {
+            case FFI_TYPE_FLOAT:
+            case FFI_TYPE_DOUBLE:
+                cif->flags += cif->rtype->type << (FFI_FLAG_BITS * 8);
+                break;
+        // long long is the same size as a word in riscv64
+        #ifndef __riscv64
+            case FFI_TYPE_SINT64:
+            case FFI_TYPE_UINT64:
+                cif->flags += FFI_TYPE_UINT64 << (FFI_FLAG_BITS * 8);
+                break;
+        #endif
+            default:
+                cif->flags += FFI_TYPE_INT << (FFI_FLAG_BITS * 8);
+                break;
+        }
+    }
+
+    return FFI_OK;
+}
+
+/* Low level routine for calling RV32 functions */
+extern int ffi_call_rv32(void (*)(char *, extended_cif *, int, int), 
+                         extended_cif *, unsigned, unsigned, 
+                         unsigned *, void (*)(void));
+
+/* Low level routine for calling RV64 functions */
+extern int ffi_call_rv64(void (*)(char *, extended_cif *, int, int), 
+                         extended_cif *, unsigned, unsigned, 
+                         unsigned *, void (*)(void));
+
+void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
+{
+    extended_cif ecif;
+
+    ecif.cif = cif;
+    ecif.avalue = avalue;
+
+    /* If the return value is a struct and we don't have a return	*/
+    /* value address then we need to make one		        */
+
+    if ((rvalue == NULL) && (cif->rtype->type == FFI_TYPE_STRUCT))
+        ecif.rvalue = alloca(cif->rtype->size);
+    else
+        ecif.rvalue = rvalue;
+
+    switch (cif->abi) 
+    {
+        case FFI_RV32:
+        case FFI_RV32_SOFT_FLOAT:
+            ffi_call_rv32(ffi_prep_args, &ecif, cif->bytes, cif->flags, ecif.rvalue, fn);
+            break;
+        case FFI_RV64:
+        case FFI_RV64_SOFT_FLOAT:
+            ffi_call_rv64(ffi_prep_args, &ecif, cif->bytes, cif->flags, ecif.rvalue, fn);
+            break;
+        default:
+            FFI_ASSERT(0);
+            break;
+    }
+}
diff --git a/src/riscv/ffi64.c b/src/riscv/ffi64.c
new file mode 100644
index 0000000..f0d45eb
--- /dev/null
+++ b/src/riscv/ffi64.c
@@ -0,0 +1,105 @@
+/* -----------------------------------------------------------------------
+   ffi64.c - 2014 Michael Knyszek
+   
+   RISC-V 64-bit Foreign Function Interface 
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#include <stdlib.h>
+
+/* Perform machine dependent cif processing */
+
+ffi_status ffi_prep_cif_machdep(ffi_cif *cif)
+{
+    int i;
+    unsigned int prev_dbl_size = 0;
+    cif->flags = 0;
+    
+    /* Set the first 8 existing argument types in the flag bit string 
+     * 
+     * We only describe the two argument types we care about:
+     * - Whether or not its a float
+     * - Whether or not its a 128 bit type (only long double)
+     * 
+     * This is is two bits per argument accounting for the first 16 bits
+     * of cif->flags.
+     * 
+     * The last 16 bits are just used to describe the return type
+     * 
+     * FFI_FLAG_BITS = 2
+     */
+    
+    for(i = 0; i < cif->nargs && i < 8; ++i)
+    {
+        
+    }
+
+    /* Set the return type flag */
+
+    if (cif->abi == FFI_RV64_SOFT_FLOAT)
+    {
+        switch (cif->rtype->type)
+        {
+            case FFI_TYPE_VOID:
+            case FFI_TYPE_POINTER:
+            case FFI_TYPE_STRUCT:
+            //case FFI_TYPE_LONG_DOUBLE:
+                cif->flags += cif->rtype->type << (FFI_FLAG_BITS * 8);
+                break;
+            case FFI_TYPE_SINT64:
+            case FFI_TYPE_UINT64:
+            case FFI_TYPE_DOUBLE:
+                cif->flags += FFI_TYPE_UINT64 << (FFI_FLAG_BITS * 8);
+                break;
+            case FFI_TYPE_FLOAT:
+            default:
+                cif->flags += FFI_TYPE_INT << (FFI_FLAG_BITS * 8);
+                break;
+        }
+    }
+    else
+    {   
+        switch (cif->rtype->type)
+        {
+            case FFI_TYPE_VOID:
+            case FFI_TYPE_POINTER:
+            case FFI_TYPE_STRUCT:
+            case FFI_TYPE_FLOAT:
+            case FFI_TYPE_DOUBLE:
+            //case FFI_TYPE_LONG_DOUBLE:
+                cif->flags += cif->rtype->type << (FFI_FLAG_BITS * 8);
+                break;
+            case FFI_TYPE_SINT64:
+            case FFI_TYPE_UINT64:
+                cif->flags += FFI_TYPE_UINT64 << (FFI_FLAG_BITS * 8);
+                break;
+            default:
+                cif->flags += FFI_TYPE_INT << (FFI_FLAG_BITS * 8);
+                break;
+        }
+    }
+
+    return FFI_OK;
+}
diff --git a/src/riscv/ffitarget.h b/src/riscv/ffitarget.h
new file mode 100644
index 0000000..d56eb59
--- /dev/null
+++ b/src/riscv/ffitarget.h
@@ -0,0 +1,74 @@
+/* -----------------------------------------------------------------*-C-*-
+   ffitarget.h - 2014 Michael Knyszek
+   
+   Target configuration macros for RISC-V.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+#ifndef LIBFFI_ASM		
+
+#define FFI_FLAG_BITS 2
+
+typedef unsigned long ffi_arg; 
+typedef   signed long ffi_sarg;
+
+typedef enum ffi_abi {
+  FFI_FIRST_ABI = 0,
+  FFI_RV32,
+  FFI_RV32_SOFT_FLOAT,
+  FFI_RV64,
+  FFI_RV64_SOFT_FLOAT,
+  FFI_LAST_ABI,
+
+#ifdef __riscv64
+  #ifdef __riscv_soft_float
+    FFI_DEFAULT_ABI = FFI_RV64_SOFT_FLOAT
+  #else
+    FFI_DEFAULT_ABI = FFI_RV64
+  #endif
+#else
+  #ifdef __riscv_soft_float
+    FFI_DEFAULT_ABI = FFI_RV32_SOFT_FLOAT
+  #else
+    FFI_DEFAULT_ABI = FFI_RV32
+  #endif
+#endif /* __riscv_soft_float */
+} ffi_abi;
+
+#endif /* LIBFFI_ASM */
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+#define FFI_CLOSURES 0
+#define FFI_TRAMPOLINE_SIZE 48
+#define FFI_NATIVE_RAW_API 0
+
+#endif
+
diff --git a/src/riscv/rv32.S b/src/riscv/rv32.S
new file mode 100644
index 0000000..c31c439
--- /dev/null
+++ b/src/riscv/rv32.S
@@ -0,0 +1,554 @@
+/* -----------------------------------------------------------------------
+   rv32.S - Michael Knyszek 2014
+   
+   RISC-V Foreign Function Interface 
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM  
+#include <fficonfig.h>
+#include <ffi.h>
+
+#define callback a0
+#define ecif     a1
+#define bytes    a2
+#define flags    a3
+#define rvalue   a4
+#define fn       a5
+#define fp       s0
+
+# The RISCV GCC compiler can't handle expressions in assembly, so
+# the workaround is this:
+
+#define FFI_SIZEOF_ARG_X0 0
+#define FFI_SIZEOF_ARG_X1 4
+#define FFI_SIZEOF_ARG_X2 8
+#define FFI_SIZEOF_ARG_X3 12
+#define FFI_SIZEOF_ARG_X4 16
+#define FFI_SIZEOF_ARG_X5 20
+#define FFI_SIZEOF_ARG_X6 24
+#define FFI_SIZEOF_ARG_X7 28
+#define FFI_SIZEOF_ARG_X8 32
+
+#define ARG_MASK 65535
+
+#define FFI_FLAG_BITS_X0 0
+#define FFI_FLAG_BITS_X1 2
+#define FFI_FLAG_BITS_X2 4
+#define FFI_FLAG_BITS_X3 6
+#define FFI_FLAG_BITS_X4 8
+#define FFI_FLAG_BITS_X5 10
+#define FFI_FLAG_BITS_X6 12
+#define FFI_FLAG_BITS_X7 14
+
+# Stack pointer needs to be 16-byte aligned, so frame size is rounded up
+# FFI_SIZEOF_ARG should be 4 in the 32-bit case
+
+    .text
+    .align  2
+    .globl  ffi_call_rv32
+    .type   ffi_call_rv32, @function
+ffi_call_rv32:   
+    ### Prologue
+    
+    # a0 - ffi_prep_args pointer
+    # a1 - extended_cif pointer
+    # a2 - bytes
+    # a3 - flags
+    # a4 - rvalue
+    # a5 - function ptr
+    
+    add     sp, sp, -FFI_SIZEOF_ARG_X8   # move stack pointer by frame size
+                                         # must be 16-byte aligned 
+    
+    # stack ptr points to first argument on stack,
+    # but there should be no arguments on the stack
+    
+    sw      flags,   FFI_SIZEOF_ARG_X0(sp)   # save flags
+    sw      rvalue,  FFI_SIZEOF_ARG_X1(sp)   # save return value pointer
+    sw      fn,      FFI_SIZEOF_ARG_X2(sp)   # save function pointer
+    sw      fp,      FFI_SIZEOF_ARG_X3(sp)   # save frame pointer
+    sw      ra,      FFI_SIZEOF_ARG_X4(sp)   # save return address
+    
+    add     fp, sp, zero             # new frame pointer is updated stack pointer
+    add     t4, callback, zero       # function ptr to prep_args
+
+    # Allocate at least 8 words on the argstack
+    ori     t0, zero, FFI_SIZEOF_ARG_X8
+    bltu    bytes, t0, thirtytwo
+
+    # Here it turns out that our total arg space is bigger than our
+    # argument register space, so we set it according to bytes
+    # and makes sure its aligned to 16 bytes
+    
+    add     t0, bytes, 15      # make sure it is aligned 
+    andi    t0, t0,   -16      # to a 16 byte boundry
+
+thirtytwo:
+    sub     sp, sp, t0 # move the stack pointer to reflect the arg space
+    
+    # a0 is the stack with proper arg space allocated
+    add     a0, sp, zero
+    
+    # a1 is ecif
+    # a2 is bytes
+    # a3 is flags
+
+    jalr    t4  # call ffi_prep_args
+    
+    lw      t0, 0(fp)                  # load the flags word
+    srli    t2, t0, 16                 # shift our return type into t4
+    
+    li      t1, ARG_MASK
+    and     t0, t0, t1                 # mask out the arg types into t0
+
+    # time to load the arguments for the call
+    
+#ifndef __riscv_soft_float
+
+####################
+## SET ARGUMENT 0 ##
+####################
+
+set_arg0:
+    srli    t1, t0, FFI_FLAG_BITS_X0 # Shift to get the bits for this argument
+    andi    t1, t1, 3               # Mask out the bits for this argument
+    
+    # when its zero, it means its just a word-sized int/ptr
+    bne     t1, zero, set_arg0_float 
+    lw      a0, FFI_SIZEOF_ARG_X0(sp) # load argument
+    j       set_arg1
+    
+set_arg0_float:
+    addi    t1, t1, -1
+    
+    # when its zero, it means its just a word-sized float
+    bne     t1, zero, set_arg0_longlong
+    flw     fa0, FFI_SIZEOF_ARG_X0(sp) # load argument
+    j       set_arg1
+    
+set_arg0_longlong:    
+    addi    t1, t1, -1
+    
+    # when its zero, it means its just a double-word-sized int/struct
+    bne     t1, zero, set_arg0_double
+    lw      a0, FFI_SIZEOF_ARG_X0(sp) # load low order bits into even
+    lw      a1, FFI_SIZEOF_ARG_X1(sp) # load high order bits into odd
+    j       set_arg2
+    
+set_arg0_double:
+    # otherwise it must be a double we're dealing with
+    flw     fa0, FFI_SIZEOF_ARG_X0(sp) # load low order bits into even
+    flw     fa1, FFI_SIZEOF_ARG_X1(sp) # load high order bits into odd
+    j       set_arg2
+
+####################
+## SET ARGUMENT 1 ##
+####################
+    
+set_arg1:
+    srli    t1, t0, FFI_FLAG_BITS_X1 # Shift to get the bits for this argument
+    andi    t1, t1, 3               # Mask out the bits for this argument
+    
+    # when its zero, it means its just a word-sized int/ptr
+    bne     t1, zero, set_arg1_float 
+    lw      a1, FFI_SIZEOF_ARG_X1(sp) # load argument
+    j       set_arg2
+    
+set_arg1_float:
+    # this is an odd register, so that means we cannot have a double-sized type
+    # here anyway. we just assume its a float, in this case.
+    flw     fa1, FFI_SIZEOF_ARG_X1(sp) # load argument
+    j       set_arg2
+    
+####################
+## SET ARGUMENT 2 ##
+####################
+
+set_arg2:
+    srli    t1, t0, FFI_FLAG_BITS_X2 # Shift to get the bits for this argument
+    andi    t1, t1, 3               # Mask out the bits for this argument
+    
+    # when its zero, it means its just a word-sized int/ptr
+    bne     t1, zero, set_arg2_float 
+    lw      a2, FFI_SIZEOF_ARG_X2(sp) # load argument
+    j       set_arg3
+    
+set_arg2_float:
+    addi    t1, t1, -1
+    
+    # when its zero, it means its just a word-sized float
+    bne     t1, zero, set_arg2_longlong
+    flw     fa2, FFI_SIZEOF_ARG_X2(sp) # load argument
+    j       set_arg3
+    
+set_arg2_longlong:    
+    addi    t1, t1, -1
+    
+    # when its zero, it means its just a double-word-sized int/struct
+    bne     t1, zero, set_arg2_double
+    lw      a2, FFI_SIZEOF_ARG_X2(sp) # load low order bits into even
+    lw      a3, FFI_SIZEOF_ARG_X3(sp) # load high order bits into odd
+    j       set_arg4
+    
+set_arg2_double:
+    # otherwise it must be a double we're dealing with
+    flw     fa2, FFI_SIZEOF_ARG_X2(sp) # load low order bits into even
+    flw     fa3, FFI_SIZEOF_ARG_X3(sp) # load high order bits into odd
+    j       set_arg4
+
+####################
+## SET ARGUMENT 3 ##
+####################
+    
+set_arg3:
+    srli    t1, t0, FFI_FLAG_BITS_X3 # Shift to get the bits for this argument
+    andi    t1, t1, 3               # Mask out the bits for this argument
+    
+    # when its zero, it means its just a word-sized int/ptr
+    bne     t1, zero, set_arg3_float 
+    lw      a3, FFI_SIZEOF_ARG_X3(sp) # load argument
+    j       set_arg4
+    
+set_arg3_float:
+    # this is an odd register, so that means we cannot have a double-sized type
+    # here anyway. we just assume its a float, in this case.
+    flw     fa3, FFI_SIZEOF_ARG_X3(sp) # load argument
+    j       set_arg4
+
+####################
+## SET ARGUMENT 4 ##
+####################
+
+set_arg4:
+    srli    t1, t0, FFI_FLAG_BITS_X4 # Shift to get the bits for this argument
+    andi    t1, t1, 3               # Mask out the bits for this argument
+    
+    # when its zero, it means its just a word-sized int/ptr
+    bne     t1, zero, set_arg4_float 
+    lw      a4, FFI_SIZEOF_ARG_X4(sp) # load argument
+    j       set_arg5
+    
+set_arg4_float:
+    addi    t1, t1, -1
+    
+    # when its zero, it means its just a word-sized float
+    bne     t1, zero, set_arg4_longlong
+    flw     fa4, FFI_SIZEOF_ARG_X4(sp) # load argument
+    j       set_arg5
+    
+set_arg4_longlong:    
+    addi    t1, t1, -1
+    
+    # when its zero, it means its just a double-word-sized int/struct
+    bne     t1, zero, set_arg4_double
+    lw      a4, FFI_SIZEOF_ARG_X4(sp) # load low order bits into even
+    lw      a5, FFI_SIZEOF_ARG_X5(sp) # load high order bits into odd
+    j       set_arg6
+    
+set_arg4_double:
+    # otherwise it must be a double we're dealing with
+    flw     fa4, FFI_SIZEOF_ARG_X4(sp) # load low order bits into even
+    flw     fa5, FFI_SIZEOF_ARG_X5(sp) # load high order bits into odd
+    j       set_arg6
+
+####################
+## SET ARGUMENT 5 ##
+####################
+    
+set_arg5:
+    srli    t1, t0, FFI_FLAG_BITS_X5 # Shift to get the bits for this argument
+    andi    t1, t1, 3               # Mask out the bits for this argument
+    
+    # when its zero, it means its just a word-sized int/ptr
+    bne     t1, zero, set_arg5_float 
+    lw      a5, FFI_SIZEOF_ARG_X5(sp) # load argument
+    j       set_arg6
+    
+set_arg5_float:
+    # this is an odd register, so that means we cannot have a double-sized type
+    # here anyway. we just assume its a float, in this case.
+    flw     fa5, FFI_SIZEOF_ARG_X5(sp) # load argument
+    j       set_arg6
+    
+####################
+## SET ARGUMENT 6 ##
+####################
+
+set_arg6:
+    srli    t1, t0, FFI_FLAG_BITS_X6 # Shift to get the bits for this argument
+    andi    t1, t1, 3               # Mask out the bits for this argument
+    
+    # when its zero, it means its just a word-sized int/ptr
+    bne     t1, zero, set_arg6_float 
+    lw      a6, FFI_SIZEOF_ARG_X6(sp) # load argument
+    j       set_arg7
+    
+set_arg6_float:
+    addi    t1, t1, -1
+    
+    # when its zero, it means its just a word-sized float
+    bne     t1, zero, set_arg6_longlong
+    flw     fa6, FFI_SIZEOF_ARG_X6(sp) # load argument
+    j       set_arg7
+    
+set_arg6_longlong:    
+    addi    t1, t1, -1
+    
+    # when its zero, it means its just a double-word-sized int/struct
+    bne     t1, zero, set_arg6_double
+    lw      a6, FFI_SIZEOF_ARG_X6(sp) # load low order bits into even
+    lw      a7, FFI_SIZEOF_ARG_X7(sp) # load high order bits into odd
+    j       call_it
+    
+set_arg6_double:
+    # otherwise it must be a double we're dealing with
+    flw     fa6, FFI_SIZEOF_ARG_X6(sp) # load low order bits into even
+    flw     fa7, FFI_SIZEOF_ARG_X7(sp) # load high order bits into odd
+    j       call_it
+
+####################
+## SET ARGUMENT 7 ##
+####################
+    
+set_arg7:
+    srli    t1, t0, FFI_FLAG_BITS_X7 # Shift to get the bits for this argument
+    andi    t1, t1, 3               # Mask out the bits for this argument
+    
+    # when its zero, it means its just a word-sized int/ptr
+    bne     t1, zero, set_arg7_float 
+    lw      a7, FFI_SIZEOF_ARG_X7(sp) # load argument
+    j       call_it
+    
+set_arg7_float:
+    # this is an odd register, so that means we cannot have a double-sized type
+    # here anyway. we just assume its a float, in this case.
+    flw     fa7, FFI_SIZEOF_ARG_X7(sp) # load argument
+    j       call_it
+    
+#else
+
+## START RISCV SOFT-FLOAT LOADING ##
+
+####################
+## SET ARGUMENT 0 ##
+####################
+
+set_arg0:
+    srli    t1, t0, FFI_FLAG_BITS_X0 # Shift to get the bits for this argument
+    andi    t1, t1, 3               # Mask out the bits for this argument
+    
+    # when its zero, it means its just a word-sized int/ptr
+    bne     t1, zero, set_arg0_longlong
+    lw      a0, FFI_SIZEOF_ARG_X0(sp) # load argument
+    j       set_arg1
+    
+set_arg0_longlong:    
+    # must be a double-word-sized argument
+    lw      a0, FFI_SIZEOF_ARG_X0(sp) # load low order bits into even
+    lw      a1, FFI_SIZEOF_ARG_X1(sp) # load high order bits into odd
+    j       set_arg2
+
+####################
+## SET ARGUMENT 1 ##
+####################
+    
+set_arg1:
+    srli    t1, t0, FFI_FLAG_BITS_X1 # Shift to get the bits for this argument
+    andi    t1, t1, 3               # Mask out the bits for this argument
+    
+    # in this case, the argument must be just word-sized
+    lw      a1, FFI_SIZEOF_ARG_X1(sp) # load argument
+    
+####################
+## SET ARGUMENT 2 ##
+####################
+
+set_arg2:
+    srli    t1, t0, FFI_FLAG_BITS_X2 # Shift to get the bits for this argument
+    andi    t1, t1, 3               # Mask out the bits for this argument
+    
+    # when its zero, it means its just a word-sized int/ptr
+    bne     t1, zero, set_arg2_longlong
+    lw      a2, FFI_SIZEOF_ARG_X2(sp) # load argument
+    j       set_arg3
+    
+set_arg2_longlong:    
+    # must be a double-word-sized argument
+    lw      a2, FFI_SIZEOF_ARG_X2(sp) # load low order bits into even
+    lw      a3, FFI_SIZEOF_ARG_X3(sp) # load high order bits into odd
+    j       set_arg4
+
+####################
+## SET ARGUMENT 3 ##
+####################
+    
+set_arg3:
+    srli    t1, t0, FFI_FLAG_BITS_X3 # Shift to get the bits for this argument
+    andi    t1, t1, 3               # Mask out the bits for this argument
+    
+    # in this case, the argument must be just word-sized
+    lw      a3, FFI_SIZEOF_ARG_X3(sp) # load argument
+
+####################
+## SET ARGUMENT 4 ##
+####################
+
+set_arg4:
+    srli    t1, t0, FFI_FLAG_BITS_X4 # Shift to get the bits for this argument
+    andi    t1, t1, 3               # Mask out the bits for this argument
+    
+    # when its zero, it means its just a word-sized int/ptr
+    bne     t1, zero, set_arg4_longlong
+    lw      a4, FFI_SIZEOF_ARG_X4(sp) # load argument
+    j       set_arg5
+    
+set_arg4_longlong:
+    # must be a double-word-sized argument
+    lw      a4, FFI_SIZEOF_ARG_X4(sp) # load low order bits into even
+    lw      a5, FFI_SIZEOF_ARG_X5(sp) # load high order bits into odd
+    j       set_arg6
+
+####################
+## SET ARGUMENT 5 ##
+####################
+    
+set_arg5:
+    srli    t1, t0, FFI_FLAG_BITS_X5 # Shift to get the bits for this argument
+    andi    t1, t1, 3               # Mask out the bits for this argument
+    
+    # in this case, the argument must be just word-sized
+    lw      a5, FFI_SIZEOF_ARG_X5(sp) # load argument
+    
+####################
+## SET ARGUMENT 6 ##
+####################
+
+set_arg6:
+    srli    t1, t0, FFI_FLAG_BITS_X6 # Shift to get the bits for this argument
+    andi    t1, t1, 3               # Mask out the bits for this argument
+    
+    # when its zero, it means its just a word-sized int/ptr
+    bne     t1, zero, set_arg6_longlong
+    lw      a6, FFI_SIZEOF_ARG_X6(sp) # load argument
+    j       set_arg7
+    
+set_arg6_longlong:    
+    addi    t1, t1, -1
+    
+    # must be a double-word-sized argument
+    lw      a6, FFI_SIZEOF_ARG_X6(sp) # load low order bits into even
+    lw      a7, FFI_SIZEOF_ARG_X7(sp) # load high order bits into odd
+    j       call_it
+
+####################
+## SET ARGUMENT 7 ##
+####################
+    
+set_arg7:
+    srli    t1, t0, FFI_FLAG_BITS_X7 # Shift to get the bits for this argument
+    andi    t1, t1, 3               # Mask out the bits for this argument
+    
+    # in this case, the argument must be just word-sized
+    lw      a7, FFI_SIZEOF_ARG_X7(sp) # load argument
+    j       call_it
+
+#endif
+
+call_it:    
+    # Load the function pointer
+    lw      t4, FFI_SIZEOF_ARG_X2(fp)
+
+    # When the return value pointer is NULL, assume no return value.
+    lw      t1, FFI_SIZEOF_ARG_X1(fp)
+    beq     t1, zero, return_void
+
+    # is the return type word-sized? if not, jump ahead
+    ori     t3, zero, FFI_TYPE_INT
+    bne     t2, t3, return_longlong 
+    
+    jalr    t4 # call the function
+    
+    # We reload the return value because it was in a temp reg and
+    # there was just a function call.
+    lw      t0, FFI_SIZEOF_ARG_X1(fp)
+    sw      a0, 0(t0)
+    j       epilogue
+
+return_longlong:
+    # is the return type double-word-sized? if not, jump ahead
+    ori     t3, zero, FFI_TYPE_UINT64
+#ifndef __riscv_soft_float
+    bne     t2, t3, return_float
+#else
+    bne     t2, t3s, return_void
+#endif
+
+    jalr    t4
+    
+    # We reload the return value because it was in a temp reg and
+    # there was just a function call.
+    lw      t0, FFI_SIZEOF_ARG_X1(fp)
+    sw      a1, FFI_SIZEOF_ARG_X1(t0)
+    sw      a0, FFI_SIZEOF_ARG_X0(t0)
+    j       epilogue
+
+#ifndef __riscv_soft_float
+return_float:
+    # is the return type a float? if not, jump ahead
+    ori     t3, zero, FFI_TYPE_FLOAT
+    bne     t2, t3, return_double
+    
+    jalr    t4
+    
+    # We reload the return value because it was in a temp reg and
+    # there was just a function call.
+    lw      t0,  FFI_SIZEOF_ARG_X1(fp)
+    fsw     fa0, FFI_SIZEOF_ARG_X0(t0)
+    j       epilogue
+
+return_double:
+    # is the return type a double? if not, give up
+    ori     t3, zero, FFI_TYPE_DOUBLE
+    bne     t2, t3, return_void
+    
+    jalr    t4
+    
+    # We reload the return value because it was in a temp reg and
+    # there was just a function call.
+    lw      t0,  FFI_SIZEOF_ARG_X1(fp)
+    fsw     fa1, FFI_SIZEOF_ARG_X1(t0)
+    fsw     fa0, FFI_SIZEOF_ARG_X0(t0)
+    j       epilogue
+#endif
+ 
+return_void:   
+    jalr    t4
+    
+epilogue:   
+    add     sp, fp, zero    
+    lw      fp, FFI_SIZEOF_ARG_X3(sp)  # Restore frame pointer
+    lw      ra, FFI_SIZEOF_ARG_X4(sp)  # Restore return address
+    add     sp, sp, FFI_SIZEOF_ARG_X8  # Fix stack pointer
+    jr      ra
+    
+    .size   ffi_call_rv32, .-ffi_call_rv32
diff --git a/src/riscv/rv64.S b/src/riscv/rv64.S
new file mode 100644
index 0000000..b315607
--- /dev/null
+++ b/src/riscv/rv64.S
@@ -0,0 +1,410 @@
+/* -----------------------------------------------------------------------
+   rv64.S - Michael Knyszek 2014
+   
+   RISC-V Foreign Function Interface 
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM  
+#include <fficonfig.h>
+#include <ffi.h>
+    
+#define callback a0
+#define ecif     a1
+#define bytes    a2
+#define flags    a3
+#define rvalue   a4
+#define fn       a5
+#define fp       s0
+
+# Can't resolve expressions, workaround is
+# explicit enumeration of values
+
+# FFI_SIZEOF_ARG = 8 in this case
+
+#define FFI_SIZEOF_ARG_X0 0
+#define FFI_SIZEOF_ARG_X1 8
+#define FFI_SIZEOF_ARG_X2 16
+#define FFI_SIZEOF_ARG_X3 24
+#define FFI_SIZEOF_ARG_X4 32
+#define FFI_SIZEOF_ARG_X5 40
+#define FFI_SIZEOF_ARG_X6 48
+#define FFI_SIZEOF_ARG_X7 56
+#define FFI_SIZEOF_ARG_X8 64
+
+#define ARG_MASK 65535
+
+#define FFI_FLAG_BITS_X0 0
+#define FFI_FLAG_BITS_X1 2
+#define FFI_FLAG_BITS_X2 4
+#define FFI_FLAG_BITS_X3 6
+#define FFI_FLAG_BITS_X4 8
+#define FFI_FLAG_BITS_X5 10
+#define FFI_FLAG_BITS_X6 12
+#define FFI_FLAG_BITS_X7 14
+
+# Stack pointer needs to be 16-byte aligned, so frame size is rounded up
+# FFI_SIZEOF_ARG should be 4 in the 32-bit case
+
+    .text
+    .align  2
+    .globl  ffi_call_rv64
+    .type   ffi_call_rv64, @function
+ffi_call_rv64:   
+    ### Prologue
+    
+    # a0 - ffi_prep_args pointer
+    # a1 - extended_cif pointer
+    # a2 - bytes
+    # a3 - flags
+    # a4 - rvalue
+    # a5 - function ptr
+    
+    add     sp, sp, -FFI_SIZEOF_ARG_X6   # move stack pointer by frame size
+                                         # must be 16-byte aligned 
+    
+    # stack ptr points to first argument on stack,
+    # but there should be no arguments on the stack
+    
+    sd      flags,   FFI_SIZEOF_ARG_X0(sp)   # save flags
+    sd      rvalue,  FFI_SIZEOF_ARG_X1(sp)   # save return value pointer
+    sd      fn,      FFI_SIZEOF_ARG_X2(sp)   # save function pointer
+    sd      fp,      FFI_SIZEOF_ARG_X3(sp)   # save frame pointer
+    sd      ra,      FFI_SIZEOF_ARG_X4(sp)   # save return address
+    
+    add     fp, sp, zero             # new frame pointer is updated stack pointer
+    add     t4, callback, zero       # function ptr to prep_args
+
+    # Allocate at least 8 words on the argstack
+    ori     t0, zero, FFI_SIZEOF_ARG_X8
+    bltu    bytes, t0, thirtytwo
+
+    # Here it turns out that our total arg space is bigger than our
+    # argument register space, so we set it according to bytes
+    # and makes sure its aligned to 16 bytes
+    
+    add     t0, bytes, 15      # make sure it is aligned 
+    andi    t0, t0,   -16      # to a 16 byte boundry
+
+thirtytwo:
+    sub     sp, sp, t0 # move the stack pointer to reflect the arg space
+    
+    # a0 is the stack with proper arg space allocated
+    add     a0, sp, zero
+    
+    # a1 is ecif
+    # a2 is bytes
+    # a3 is flags
+
+    jalr    t4  # call ffi_prep_args
+    
+    ld      t0, 0(fp)                  # load the flags word
+    srli    t2, t0, 16                 # shift our return type into t4
+    
+    li      t1, ARG_MASK
+    and     t0, t0, t1                 # mask out the arg types into t0
+
+    # time to load the arguments for the call
+
+#ifndef __riscv_soft_float
+
+####################
+## SET ARGUMENT 0 ##
+####################
+
+set_arg0:
+    srli    t1, t0, FFI_FLAG_BITS_X0 # Shift to get the bits for this argument
+    andi    t1, t1, 3               # Mask out the bits for this argument
+    
+    # when its zero, it means its just a word-sized int/ptr
+    bne     t1, zero, set_arg0_float 
+    ld      a0, FFI_SIZEOF_ARG_X0(sp) # load argument
+    j       set_arg1
+    
+set_arg0_float:
+    addi    t1, t1, -1
+    
+    # when its zero, it means its just a word-sized float
+    bne     t1, zero, set_arg0_double
+    flw     fa0, FFI_SIZEOF_ARG_X0(sp) # load argument
+    j       set_arg1
+    
+set_arg0_double:
+    # otherwise it must be a double we're dealing with
+    fld     fa0, FFI_SIZEOF_ARG_X0(sp)
+
+####################
+## SET ARGUMENT 1 ##
+####################
+
+set_arg1:
+    srli    t1, t0, FFI_FLAG_BITS_X1 # Shift to get the bits for this argument
+    andi    t1, t1, 3               # Mask out the bits for this argument
+    
+    # when its zero, it means its just a word-sized int/ptr
+    bne     t1, zero, set_arg1_float 
+    ld      a1, FFI_SIZEOF_ARG_X1(sp) # load argument
+    j       set_arg2
+    
+set_arg1_float:
+    addi    t1, t1, -1
+    
+    # when its zero, it means its just a word-sized float
+    bne     t1, zero, set_arg1_double
+    flw     fa1, FFI_SIZEOF_ARG_X1(sp) # load argument
+    j       set_arg2
+    
+set_arg1_double:
+    # otherwise it must be a double we're dealing with
+    fld     fa1, FFI_SIZEOF_ARG_X1(sp)
+
+####################
+## SET ARGUMENT 2 ##
+####################
+
+set_arg2:
+    srli    t1, t0, FFI_FLAG_BITS_X2 # Shift to get the bits for this argument
+    andi    t1, t1, 3               # Mask out the bits for this argument
+    
+    # when its zero, it means its just a word-sized int/ptr
+    bne     t1, zero, set_arg2_float 
+    ld      a2, FFI_SIZEOF_ARG_X2(sp) # load argument
+    j       set_arg3
+    
+set_arg2_float:
+    addi    t1, t1, -1
+    
+    # when its zero, it means its just a word-sized float
+    bne     t1, zero, set_arg2_double
+    flw     fa2, FFI_SIZEOF_ARG_X2(sp) # load argument
+    j       set_arg3
+    
+set_arg2_double:
+    # otherwise it must be a double we're dealing with
+    fld     fa2, FFI_SIZEOF_ARG_X2(sp)
+
+####################
+## SET ARGUMENT 3 ##
+####################
+
+set_arg3:
+    srli    t1, t0, FFI_FLAG_BITS_X3 # Shift to get the bits for this argument
+    andi    t1, t1, 3               # Mask out the bits for this argument
+    
+    # when its zero, it means its just a word-sized int/ptr
+    bne     t1, zero, set_arg3_float 
+    ld      a3, FFI_SIZEOF_ARG_X3(sp) # load argument
+    j       set_arg4
+    
+set_arg3_float:
+    addi    t1, t1, -1
+    
+    # when its zero, it means its just a word-sized float
+    bne     t1, zero, set_arg3_double
+    flw     fa3, FFI_SIZEOF_ARG_X3(sp) # load argument
+    j       set_arg4
+    
+set_arg3_double:
+    # otherwise it must be a double we're dealing with
+    fld     fa3, FFI_SIZEOF_ARG_X3(sp)
+
+####################
+## SET ARGUMENT 4 ##
+####################
+
+set_arg4:
+    srli    t1, t0, FFI_FLAG_BITS_X4 # Shift to get the bits for this argument
+    andi    t1, t1, 3               # Mask out the bits for this argument
+    
+    # when its zero, it means its just a word-sized int/ptr
+    bne     t1, zero, set_arg4_float 
+    ld      a4, FFI_SIZEOF_ARG_X4(sp) # load argument
+    j       set_arg5
+    
+set_arg4_float:
+    addi    t1, t1, -1
+    
+    # when its zero, it means its just a word-sized float
+    bne     t1, zero, set_arg4_double
+    flw     fa4, FFI_SIZEOF_ARG_X4(sp) # load argument
+    j       set_arg5
+    
+set_arg4_double:
+    # otherwise it must be a double we're dealing with
+    fld     fa4, FFI_SIZEOF_ARG_X4(sp)
+
+####################
+## SET ARGUMENT 5 ##
+####################
+
+set_arg5:
+    srli    t1, t0, FFI_FLAG_BITS_X5 # Shift to get the bits for this argument
+    andi    t1, t1, 3               # Mask out the bits for this argument
+    
+    # when its zero, it means its just a word-sized int/ptr
+    bne     t1, zero, set_arg5_float 
+    ld      a5, FFI_SIZEOF_ARG_X5(sp) # load argument
+    j       set_arg6
+    
+set_arg5_float:
+    addi    t1, t1, -1
+    
+    # when its zero, it means its just a word-sized float
+    bne     t1, zero, set_arg5_double
+    flw     fa5, FFI_SIZEOF_ARG_X5(sp) # load argument
+    j       set_arg6
+    
+set_arg5_double:
+    # otherwise it must be a double we're dealing with
+    fld     fa5, FFI_SIZEOF_ARG_X5(sp)
+
+####################
+## SET ARGUMENT 6 ##
+####################
+
+set_arg6:
+    srli    t1, t0, FFI_FLAG_BITS_X6 # Shift to get the bits for this argument
+    andi    t1, t1, 3               # Mask out the bits for this argument
+    
+    # when its zero, it means its just a word-sized int/ptr
+    bne     t1, zero, set_arg6_float 
+    ld      a6, FFI_SIZEOF_ARG_X6(sp) # load argument
+    j       set_arg7
+    
+set_arg6_float:
+    addi    t1, t1, -1
+    
+    # when its zero, it means its just a word-sized float
+    bne     t1, zero, set_arg6_double
+    flw     fa6, FFI_SIZEOF_ARG_X6(sp) # load argument
+    j       set_arg7
+    
+set_arg6_double:
+    # otherwise it must be a double we're dealing with
+    fld     fa6, FFI_SIZEOF_ARG_X6(sp)
+
+####################
+## SET ARGUMENT 7 ##
+####################
+
+set_arg7:
+    srli    t1, t0, FFI_FLAG_BITS_X7 # Shift to get the bits for this argument
+    andi    t1, t1, 3               # Mask out the bits for this argument
+    
+    # when its zero, it means its just a word-sized int/ptr
+    bne     t1, zero, set_arg7_float 
+    ld      a7, FFI_SIZEOF_ARG_X7(sp) # load argument
+    j       call_it
+    
+set_arg7_float:
+    addi    t1, t1, -1
+    
+    # when its zero, it means its just a word-sized float
+    bne     t1, zero, set_arg7_double
+    flw     fa7, FFI_SIZEOF_ARG_X7(sp) # load argument
+    j       call_it
+    
+set_arg7_double:
+    # otherwise it must be a double we're dealing with
+    fld     fa7, FFI_SIZEOF_ARG_X7(sp)
+    
+#else
+
+## START RISCV SOFT-FLOAT LOADING ##
+
+    # In the soft-float case, we have no primitive datatype
+    # that has a size of >8 bytes. Therefore, we can 
+    # just load everything quite easily and nicely.
+
+    ld      a0, FFI_SIZEOF_ARG_X0(sp) # load argument
+    ld      a1, FFI_SIZEOF_ARG_X1(sp) # load argument
+    ld      a2, FFI_SIZEOF_ARG_X2(sp) # load argument
+    ld      a3, FFI_SIZEOF_ARG_X3(sp) # load argument
+    ld      a4, FFI_SIZEOF_ARG_X4(sp) # load argument
+    ld      a5, FFI_SIZEOF_ARG_X5(sp) # load argument
+    ld      a6, FFI_SIZEOF_ARG_X6(sp) # load argument
+    ld      a7, FFI_SIZEOF_ARG_X7(sp) # load argument
+
+#endif
+
+call_it:    
+    # Load the function pointer
+    ld      t4, FFI_SIZEOF_ARG_X2(fp)
+
+    # When the return value pointer is NULL, assume no return value.
+    ld      t1, FFI_SIZEOF_ARG_X1(fp)
+    beq     t1, zero, return_void
+
+    # is the return type an int? if not, and if we have an FPU,
+    # jump ahead
+#ifndef __riscv_soft_float
+    ori     t3, zero, FFI_TYPE_INT
+    bne     t2, t3, return_float
+#endif
+    
+    jalr    t4 # call the function
+    
+    # We reload the return value because it was in a temp reg and
+    # there was just a function call.
+    ld      t0, FFI_SIZEOF_ARG_X1(fp)
+    sd      a0, 0(t0)
+    j       epilogue
+
+#ifndef __riscv_soft_float
+return_float:
+    # is the return type a float? if not, jump ahead
+    ori     t3, zero, FFI_TYPE_FLOAT
+    bne     t2, t3, return_double
+    
+    jalr    t4 # call the function
+    
+    # We reload the return value because it was in a temp reg and
+    # there was just a function call.
+    ld      t0,  FFI_SIZEOF_ARG_X1(fp)
+    fsw     fa0, FFI_SIZEOF_ARG_X0(t0)
+    j       epilogue
+
+return_double:
+    # is the return type a double? if not, give up
+    ori     t3, zero, FFI_TYPE_DOUBLE
+    bne     t2, t3, return_void
+    
+    jalr    t4 # call the function
+    
+    # We reload the return value because it was in a temp reg and
+    # there was just a function call.
+    ld      t0,  FFI_SIZEOF_ARG_X1(fp)
+    fsd     fa0, FFI_SIZEOF_ARG_X0(t0)
+    j       epilogue
+#endif
+ 
+return_void:   
+    jalr    t4 # call the function
+    
+epilogue:   
+    add     sp, fp, zero    
+    ld      fp, FFI_SIZEOF_ARG_X3(sp)  # Restore frame pointer
+    ld      ra, FFI_SIZEOF_ARG_X4(sp)  # Restore return address
+    add     sp, sp, FFI_SIZEOF_ARG_X8  # Fix stack pointer
+    jr      ra
+    
+    .size   ffi_call_rv64, .-ffi_call_rv64
diff --git a/testsuite/Makefile.am b/testsuite/Makefile.am
index edc6e61..2a5c1b1 100644
--- a/testsuite/Makefile.am
+++ b/testsuite/Makefile.am
@@ -45,7 +45,7 @@ libffi.call/cls_12byte.c libffi.call/cls_multi_sshortchar.c		\
 libffi.call/cls_align_longdouble_split2.c libffi.call/return_dbl2.c	\
 libffi.call/return_fl3.c libffi.call/stret_medium.c			\
 libffi.call/nested_struct6.c libffi.call/closure_fn3.c			\
-libffi.call/float3.c libffi.call/many2.c				\
+libffi.call/float3.c libffi.call/many2.c libffi.call/many3.c		\
 libffi.call/closure_stdcall.c libffi.call/cls_align_uint16.c		\
 libffi.call/cls_9byte1.c libffi.call/closure_fn6.c			\
 libffi.call/cls_double_va.c libffi.call/cls_align_pointer.c		\
diff --git a/testsuite/libffi.call/many3.c b/testsuite/libffi.call/many3.c
new file mode 100644
index 0000000..d7396da
--- /dev/null
+++ b/testsuite/libffi.call/many3.c
@@ -0,0 +1,59 @@
+/* Area:	ffi_call
+   Purpose:	Check return value int, with many arguments
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+#include <stdlib.h>
+//#include <int.h>
+#include <math.h>
+
+static int ABI_ATTR many(int f1, int f2, int f3, int f4, int f5, int f6, int f7, int f8, int f9, int f10, int f11, int f12, int f13)
+{
+#if 0
+  printf("%f %f %f %f %f %f %f %f %f %f %f %f %f\n",
+	 (double) f1, (double) f2, (double) f3, (double) f4, (double) f5, 
+	 (double) f6, (double) f7, (double) f8, (double) f9, (double) f10,
+	 (double) f11, (double) f12, (double) f13);
+#endif
+
+  return f1+f2+f3+f4+f5+f6+f7+f8+f9+f10+f11+f12+f13;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[13];
+  void *values[13];
+  int fa[13];
+  int f, ff;
+  int i;
+
+  for (i = 0; i < 13; i++)
+    {
+      args[i] = &ffi_type_sint;
+      values[i] = &fa[i];
+      fa[i] = (int) i;
+    }
+
+    /* Initialize the cif */
+    CHECK(ffi_prep_cif(&cif, ABI_NUM, 13,
+		       &ffi_type_sint, args) == FFI_OK);
+
+    ffi_call(&cif, FFI_FN(many), &f, values);
+
+    ff =  many(fa[0], fa[1],
+	       fa[2], fa[3],
+	       fa[4], fa[5],
+	       fa[6], fa[7],
+	       fa[8], fa[9],
+	       fa[10],fa[11],fa[12]);
+
+    if (f == ff)
+      exit(0);
+    else
+      abort();
+}
